*terraform-functions.txt*                            Terraform version v1.12.x

ABS                                                        *terraform-function-abs*

https://developer.hashicorp.com/terraform/language/functions/abs

---
page_title: abs - Functions - Configuration Language
description: The abs function returns the absolute value of the given number.
---

# `abs` function reference

This topic provides reference information about the `abs` function. The `abs` function returns the absolute value of the given number.

## Introduction

The `abs` function returns the absolute value of the given number. If the number is zero or positive, the function returns the value as-is, but if it is negative, it is multiplied by -1 to make it positive before returning it.

## Syntax

Use the `abs` function with the following syntax:

```hcl
abs(number) 
```

The `number` argument is the number you want the absolute value of.

In the following example, the function returns the absolute value of `23`, `0`, and `-12.4`.

```hcl hideClipboard
$ abs(23)
23
$ abs(0)
0
$ abs(-12.4)
12.4
```

## Example use case

The following example defines a variable `num` that is negative. The function outputs the absolute value of `num`, which is `10`.

```hcl
variable "num" {
  default = -10
}

output "absolute_value" {
  value = abs(var.num)
}
```

## Related Functions

- [`signum`](/terraform/language/functions/signum) determines the sign of a number, returning a number between -1 and 1 to represent the sign

ABSPATH                                                    *terraform-function-abspath*

https://developer.hashicorp.com/terraform/language/functions/abspath

---
page_title: abspath - Functions - Configuration Language
description: The abspath function converts the argument to an absolute filesystem path.
---

# `abspath` Function

`abspath` takes a string containing a filesystem path and converts it
to an absolute path. That is, if the path is not absolute, it will be joined
with the current working directory.

Referring directly to filesystem paths in resource arguments may cause
spurious diffs if the same configuration is applied from multiple systems or on
different host operating systems. We recommend using filesystem paths only
for transient values, such as the argument to [`file`](/terraform/language/functions/file) (where
only the contents are then stored) or in `connection` and `provisioner` blocks.

## Examples

```
> abspath(path.root)
/home/user/some/terraform/root
```

ALLTRUE                                                    *terraform-function-alltrue*

https://developer.hashicorp.com/terraform/language/functions/alltrue

---
page_title: alltrue - Functions - Configuration Language
description: |-
  The alltrue function determines whether all elements of a collection
  are true or "true". If the collection is empty, it returns true.
---

# `alltrue` Function

-> **Note:** This function is available in Terraform 0.14 and later.

`alltrue` returns `true` if all elements in a given collection are `true`
or `"true"`. It also returns `true` if the collection is empty.

```hcl
alltrue(list)
```

## Examples

```command
> alltrue(["true", true])
true
> alltrue([true, false])
false
```

ANYTRUE                                                    *terraform-function-anytrue*

https://developer.hashicorp.com/terraform/language/functions/anytrue

---
page_title: anytrue - Functions - Configuration Language
description: |-
  The anytrue function determines whether any element of a collection
  is true or "true". If the collection is empty, it returns false.
---

# `anytrue` Function

-> **Note:** This function is available in Terraform 0.14 and later.

`anytrue` returns `true` if any element in a given collection is `true`
or `"true"`. It also returns `false` if the collection is empty.

```hcl
anytrue(list)
```

## Examples

```command
> anytrue(["true"])
true
> anytrue([true])
true
> anytrue([true, false])
true
> anytrue([])
false
```

BASE64DECODE                                               *terraform-function-base64decode*

https://developer.hashicorp.com/terraform/language/functions/base64decode

---
page_title: base64decode - Functions - Configuration Language
description: The base64decode function decodes a string containing a base64 sequence.
---

# `base64decode` Function

`base64decode` takes a string containing a Base64 character sequence and
returns the original string.

Terraform uses the "standard" Base64 alphabet as defined in
[RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).

Strings in the Terraform language are sequences of unicode characters rather
than bytes, so this function will also interpret the resulting bytes as
UTF-8. If the bytes after Base64 decoding are _not_ valid UTF-8, this function
produces an error.

While we do not recommend manipulating large, raw binary data in the Terraform
language, Base64 encoding is the standard way to represent arbitrary byte
sequences, and so resource types that accept or return binary data will use
Base64 themselves, which avoids the need to encode or decode it directly in
most cases. Various other functions with names containing "base64" can generate
or manipulate Base64 data directly.

`base64decode` is, in effect, a shorthand for calling
[`textdecodebase64`](/terraform/language/functions/textdecodebase64) with the encoding name set to
`UTF-8`.

## Examples

```
> base64decode("SGVsbG8gV29ybGQ=")
Hello World
```

## Related Functions

* [`base64encode`](/terraform/language/functions/base64encode) performs the opposite operation,
  encoding the UTF-8 bytes for a string as Base64.
* [`textdecodebase64`](/terraform/language/functions/textdecodebase64) is a more general function that
  supports character encodings other than UTF-8.
* [`base64gzip`](/terraform/language/functions/base64gzip) applies gzip compression to a string
  and returns the result with Base64 encoding.
* [`filebase64`](/terraform/language/functions/filebase64) reads a file from the local filesystem
  and returns its raw bytes with Base64 encoding.

BASE64ENCODE                                               *terraform-function-base64encode*

https://developer.hashicorp.com/terraform/language/functions/base64encode

---
page_title: base64encode - Functions - Configuration Language
description: The base64encode function applies Base64 encoding to a string.
---

# `base64encode` Function

`base64encode` applies Base64 encoding to a string.

Terraform uses the "standard" Base64 alphabet as defined in
[RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).

Strings in the Terraform language are sequences of unicode characters rather
than bytes, so this function will first encode the characters from the string
as UTF-8, and then apply Base64 encoding to the result.

The Terraform language applies Unicode normalization to all strings, and so
passing a string through `base64decode` and then `base64encode` may not yield
the original result exactly.

While we do not recommend manipulating large, raw binary data in the Terraform
language, Base64 encoding is the standard way to represent arbitrary byte
sequences, and so resource types that accept or return binary data will use
Base64 themselves, and so this function exists primarily to allow string
data to be easily provided to resource types that expect Base64 bytes.

`base64encode` is, in effect, a shorthand for calling
[`textencodebase64`](/terraform/language/functions/textencodebase64) with the encoding name set to
`UTF-8`.

## Examples

```
> base64encode("Hello World")
SGVsbG8gV29ybGQ=
```

## Related Functions

* [`base64decode`](/terraform/language/functions/base64decode) performs the opposite operation,
  decoding Base64 data and interpreting it as a UTF-8 string.
* [`textencodebase64`](/terraform/language/functions/textencodebase64) is a more general function that
  supports character encodings other than UTF-8.
* [`base64gzip`](/terraform/language/functions/base64gzip) applies gzip compression to a string
  and returns the result with Base64 encoding all in one operation.
* [`filebase64`](/terraform/language/functions/filebase64) reads a file from the local filesystem
  and returns its raw bytes with Base64 encoding, without creating an
  intermediate Unicode string.

BASE64GZIP                                                 *terraform-function-base64gzip*

https://developer.hashicorp.com/terraform/language/functions/base64gzip

---
page_title: base64gzip function reference - Functions - Configuration Language
description: |-
  The base64encode function compresses an HCL string using gzip, and then encodes it using Base64 encoding.
---

# `base64gzip` function reference

This topic provides reference information about the `base64gzip` function.
The `base64gzip` function compresses an HCL string using gzip and then encodes the string using Base64 encoding.

## Introduction

You can use the `base64gzip` function to compress an HCL string and then encode it in the Base64 format.
Terraform uses the standard Base64 alphabet that is defined in [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-4).

While HashiCorp does not recommend manipulating large, raw binary data in HCL, Base64 encoding can be an effective way to represent small binary objects in memory when you need to pass them as values, rather than referring to files on disk.
For example, you could use the `base64gzip` function to compress a large JSON string so that you can upload it to S3.

Because HCL strings are sequences of unicode characters rather than bytes, `base64gzip` first encodes the characters in the string as UTF-8.
Then it applies gzip compression and encodes the string using Base64 format.

## Syntax

Use the `base64gzip` function with the following syntax:

```hcl
base64gzip(ARGS)
```

The argument is the string that you want to compress and encode.

In the following example, the function compresses the string at `local.my_data` and encodes it using the Base64 format.

```hcl
base64gzip(local.my_data)
```

## Example use case

The following example defines a local value `my_data` that contains the string you want to compress and encode.
The `base64gzip` function compresses and encodes the string, and then it is used to populate an S3 bucket.

```hcl
resource "aws_s3_object" "example" {
  bucket = "my_bucket"
  key = "example.txt"
  content_base64 = base64gzip(local.my_data)
  content_encoding = "gzip"
}
```

## Related functions

* [`base64encode`](/terraform/language/functions/base64encode) applies Base64 encoding to an HCL string without using gzip compression.
* [`filebase64`](/terraform/language/functions/filebase64) reads a file from the local filesystem and encodes its raw bits using the Base64 format.

BASE64SHA256                                               *terraform-function-base64sha256*

https://developer.hashicorp.com/terraform/language/functions/base64sha256

---
page_title: base64sha256 - Functions - Configuration Language
description: |-
  The base64sha256 function computes the SHA256 hash of a given string and
  encodes it with Base64.
---

# `base64sha256` Function

`base64sha256` computes the SHA256 hash of a given string and encodes it with
Base64. This is not equivalent to `base64encode(sha256("test"))` since `sha256()`
returns hexadecimal representation.

The given string is first encoded as UTF-8 and then the SHA256 algorithm is applied
as defined in [RFC 4634](https://tools.ietf.org/html/rfc4634). The raw hash is
then encoded with Base64 before returning. Terraform uses the "standard" Base64
alphabet as defined in [RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).

## Examples

```
> base64sha256("hello world")
uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek=
```

## Related Functions

* [`filebase64sha256`](/terraform/language/functions/filebase64sha256) calculates the same hash from
  the contents of a file rather than from a string value.
* [`sha256`](/terraform/language/functions/sha256) calculates the same hash but returns the result
  in a more-verbose hexadecimal encoding.

BASE64SHA512                                               *terraform-function-base64sha512*

https://developer.hashicorp.com/terraform/language/functions/base64sha512

---
page_title: base64sha512 - Functions - Configuration Language
description: |-
  The base64sha512 function computes the SHA512 hash of a given string and
  encodes it with Base64.
---

# `base64sha512` Function

`base64sha512` computes the SHA512 hash of a given string and encodes it with
Base64. This is not equivalent to `base64encode(sha512("test"))` since `sha512()`
returns hexadecimal representation.

The given string is first encoded as UTF-8 and then the SHA512 algorithm is applied
as defined in [RFC 4634](https://tools.ietf.org/html/rfc4634). The raw hash is
then encoded with Base64 before returning. Terraform uses the "standard" Base64
alphabet as defined in [RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).

## Examples

```
> base64sha512("hello world")
MJ7MSJwS1utMxA9QyQLytNDtd+5RGnx6m808qG1M2G+YndNbxf9JlnDaNCVbRbDP2DDoH2Bdz33FVC6TrpzXbw==
```

## Related Functions

* [`filebase64sha512`](/terraform/language/functions/filebase64sha512) calculates the same hash from
  the contents of a file rather than from a string value.
* [`sha512`](/terraform/language/functions/sha512) calculates the same hash but returns the result
  in a more-verbose hexadecimal encoding.

BASENAME                                                   *terraform-function-basename*

https://developer.hashicorp.com/terraform/language/functions/basename

---
page_title: basename - Functions - Configuration Language
description: |-
  The basename function removes all except the last portion from a filesystem
  path.
---

# `basename` Function

`basename` takes a string containing a filesystem path and removes all except
the last portion from it.

This function works only with the path string and does not access the
filesystem itself. It is therefore unable to take into account filesystem
features such as symlinks.

If the path is empty then the result is `"."`, representing the current
working directory.

The behavior of this function depends on the host platform. On Windows systems,
it uses backslash `\` as the path segment separator. On Unix systems, the slash
`/` is used.

Referring directly to filesystem paths in resource arguments may cause
spurious diffs if the same configuration is applied from multiple systems or on
different host operating systems. We recommend using filesystem paths only
for transient values, such as the argument to [`file`](/terraform/language/functions/file) (where
only the contents are then stored) or in `connection` and `provisioner` blocks.

## Examples

```
> basename("foo/bar/baz.txt")
baz.txt
```

## Related Functions

* [`dirname`](/terraform/language/functions/dirname) returns all of the segments of a filesystem path
  _except_ the last, discarding the portion that would be returned by
  `basename`.

BCRYPT                                                     *terraform-function-bcrypt*

https://developer.hashicorp.com/terraform/language/functions/bcrypt

---
page_title: bcrypt - Functions - Configuration Language
description: |-
  The bcrypt function computes a hash of the given string using the Blowfish
  cipher.
---

# `bcrypt` Function

`bcrypt` computes a hash of the given string using the Blowfish cipher,
returning a string in
[the _Modular Crypt Format_](https://passlib.readthedocs.io/en/stable/modular_crypt_format.html)
usually expected in the shadow password file on many Unix systems.

```hcl
bcrypt(string, cost)
```

The `cost` argument is optional and will default to 10 if unspecified.

Since a bcrypt hash value includes a randomly selected salt, each call to this
function will return a different value, even if the given string and cost are
the same. Using this function directly with resource arguments will therefore
cause spurious diffs. We recommend using this function only in `provisioner`
blocks, or in data resources whose results are only used in `provisioner`
blocks.

The version prefix on the generated string (e.g. `$2a$`) may change in future
versions of Terraform.

## Examples

```
> bcrypt("hello world")
$2a$10$D5grTTzcsqyvAeIAnY/mYOIqliCoG7eAMX0/oFcuD.iErkksEbcAa
```

CAN                                                        *terraform-function-can*

https://developer.hashicorp.com/terraform/language/functions/can

---
page_title: can - Functions - Configuration Language
description: |-
  The can function tries to evaluate an expression given as an argument and
  indicates whether the evaluation succeeded.
---

# `can` Function

`can` evaluates the given expression and returns a boolean value indicating
whether the expression produced a result without any errors.

This is a special function that is able to catch errors produced when evaluating
its argument. For most situations where you could use `can` it's better to use
[`try`](/terraform/language/functions/try) instead, because it allows for more concise definition of
fallback values for failing expressions.

The primary purpose of `can` is to turn an error condition into a boolean
validation result when writing
[custom variable validation rules](/terraform/language/values/variables#custom-validation-rules).
For example:

```hcl
variable "timestamp" {
  type        = string

  validation {
    # formatdate fails if the second argument is not a valid timestamp
    condition     = can(formatdate("", var.timestamp))
    error_message = "The timestamp argument requires a valid RFC 3339 timestamp."
  }
}
```

The `can` function can only catch and handle _dynamic_ errors resulting from
access to data that isn't known until runtime. It will not catch errors
relating to expressions that can be proven to be invalid for any input, such
as a malformed resource reference.

~> **Warning:** The `can` function is intended only for simple tests in
variable validation rules. Although it can technically accept any sort of
expression and be used elsewhere in the configuration, we recommend against
using it in other contexts. For error handling elsewhere in the configuration,
prefer to use [`try`](/terraform/language/functions/try).

## Examples

```
> local.foo
{
  "bar" = "baz"
}
> can(local.foo.bar)
true
> can(local.foo.boop)
false
```

The `can` function will _not_ catch errors relating to constructs that are
provably invalid even before dynamic expression evaluation, such as a malformed
reference or a reference to a top-level object that has not been declared:

```
> can(local.nonexist)

Error: Reference to undeclared local value

A local value with the name "nonexist" has not been declared.
```

## Related Functions

* [`try`](/terraform/language/functions/try), which tries evaluating a sequence of expressions and
  returns the result of the first one that succeeds.

CEIL                                                       *terraform-function-ceil*

https://developer.hashicorp.com/terraform/language/functions/ceil

---
page_title: ceil - Functions - Configuration Language
description: |-
  The ceil function returns the closest whole number greater than or equal to
  the given value.
---

# `ceil` Function

`ceil` returns the closest whole number that is greater than or equal to the
given value, which may be a fraction.

## Examples

```
> ceil(5)
5
> ceil(5.1)
6
```

## Related Functions

* [`floor`](/terraform/language/functions/floor), which rounds to the nearest whole number _less than_
  or equal.

CHOMP                                                      *terraform-function-chomp*

https://developer.hashicorp.com/terraform/language/functions/chomp

---
page_title: chomp - Functions - Configuration Language
description: The chomp function removes newline characters at the end of a string.
---

# `chomp` Function

`chomp` removes newline characters at the end of a string.

This can be useful if, for example, the string was read from a file that has
a newline character at the end.

## Examples

```
> chomp("hello\n")
hello
> chomp("hello\r\n")
hello
> chomp("hello\n\n")
hello
```

## Related Functions

* [`trimspace`](/terraform/language/functions/trimspace), which removes all types of whitespace from
  both the start and the end of a string.

CHUNKLIST                                                  *terraform-function-chunklist*

https://developer.hashicorp.com/terraform/language/functions/chunklist

---
page_title: chunklist - Functions - Configuration Language
description: |-
  The chunklist function splits a single list into fixed-size chunks, returning
  a list of lists.
---

# `chunklist` Function

`chunklist` splits a single list into fixed-size chunks, returning a list
of lists.

```hcl
chunklist(list, chunk_size)
```

## Examples

```
> chunklist(["a", "b", "c", "d", "e"], 2)
[
  [
    "a",
    "b",
  ],
  [
    "c",
    "d",
  ],
  [
    "e",
  ],
]
> chunklist(["a", "b", "c", "d", "e"], 1)
[
  [
    "a",
  ],
  [
    "b",
  ],
  [
    "c",
  ],
  [
    "d",
  ],
  [
    "e",
  ],
]
```

CIDRHOST                                                   *terraform-function-cidrhost*

https://developer.hashicorp.com/terraform/language/functions/cidrhost

---
page_title: cidrhost - Functions - Configuration Language
description: |-
  The cidrhost function calculates a full host IP address within a given
  IP network address prefix.
---

# `cidrhost` Function

`cidrhost` calculates a full host IP address for a given host number within
a given IP network address prefix.

```hcl
cidrhost(prefix, hostnum)
```

`prefix` must be given in CIDR notation, as defined in
[RFC 4632 section 3.1](https://tools.ietf.org/html/rfc4632#section-3.1).

`hostnum` is a whole number that can be represented as a binary integer with
no more than the number of digits remaining in the address after the given
prefix. If `hostnum` is negative, the count starts from the end of the range.
For example, `cidrhost("10.0.0.0/8", 2)` returns `10.0.0.2` and
`cidrhost("10.0.0.0/8", -2)` returns `10.255.255.254`.

For more details on how this function interprets CIDR prefixes and
populates host numbers, see the worked example for
[`cidrsubnet`](/terraform/language/functions/cidrsubnet).

Conventionally host number zero is used to represent the address of the
network itself and the host number that would fill all the host bits with
binary 1 represents the network's broadcast address. These numbers should
generally not be used to identify individual hosts except in unusual
situations, such as point-to-point links.

This function accepts both IPv6 and IPv4 prefixes, and the result always uses
the same addressing scheme as the given prefix.

-> **Note:** As a historical accident, this function interprets IPv4 address
octets that have leading zeros as decimal numbers, which is contrary to some
other systems which interpret them as octal. We have preserved this behavior
for backward compatibility, but recommend against relying on this behavior.

## Examples

```
> cidrhost("10.12.112.0/20", 16)
10.12.112.16
> cidrhost("10.12.112.0/20", 268)
10.12.113.12
> cidrhost("fd00:fd12:3456:7890:00a2::/72", 34)
fd00:fd12:3456:7890::22
```

## Related Functions

* [`cidrsubnet`](/terraform/language/functions/cidrsubnet) calculates a subnet address under a given
  network address prefix.

CIDRNETMASK                                                *terraform-function-cidrnetmask*

https://developer.hashicorp.com/terraform/language/functions/cidrnetmask

---
page_title: cidrnetmask - Functions - Configuration Language
description: |-
  The cidrnetmask function converts an IPv4 address prefix given in CIDR
  notation into a subnet mask address.
---

# `cidrnetmask` Function

`cidrnetmask` converts an IPv4 address prefix given in CIDR notation into
a subnet mask address.

```hcl
cidrnetmask(prefix)
```

`prefix` must be given in IPv4 CIDR notation, as defined in
[RFC 4632 section 3.1](https://tools.ietf.org/html/rfc4632#section-3.1).

The result is a subnet address formatted in the conventional dotted-decimal
IPv4 address syntax, as expected by some software.

The `cidrnetmask` function only accepts IPv4 addresses in CIDR notation.
If you use an IPv6 address, `cidrnetmask` returns an error. 

-> **Note:** As a historical accident, this function interprets IPv4 address
octets that have leading zeros as decimal numbers, which is contrary to some
other systems which interpret them as octal. We have preserved this behavior
for backward compatibility, but recommend against relying on this behavior.

## Examples

```
> cidrnetmask("172.16.0.0/12")
255.240.0.0
```

CIDRSUBNET                                                 *terraform-function-cidrsubnet*

https://developer.hashicorp.com/terraform/language/functions/cidrsubnet

---
page_title: cidrsubnet - Functions - Configuration Language
description: |-
  The cidrsubnet function calculates a subnet address within a given IP network
  address prefix.
---

# `cidrsubnet` Function

`cidrsubnet` calculates a subnet address within given IP network address prefix.

```hcl
cidrsubnet(prefix, newbits, netnum)
```

`prefix` must be given in CIDR notation, as defined in
[RFC 4632 section 3.1](https://tools.ietf.org/html/rfc4632#section-3.1).

`newbits` is the number of additional bits with which to extend the prefix.
For example, if given a prefix ending in `/16` and a `newbits` value of
`4`, the resulting subnet address will have length `/20`.

`netnum` is a whole number that can be represented as a binary integer with
no more than `newbits` binary digits, which will be used to populate the
additional bits added to the prefix.

This function accepts both IPv6 and IPv4 prefixes, and the result always uses
the same addressing scheme as the given prefix.

Unlike the related function [`cidrsubnets`](/terraform/language/functions/cidrsubnets), `cidrsubnet`
allows you to give a specific network number to use. `cidrsubnets` can allocate
multiple network addresses at once, but numbers them automatically starting
with zero.

-> **Note:** As a historical accident, this function interprets IPv4 address
octets that have leading zeros as decimal numbers, which is contrary to some
other systems which interpret them as octal. We have preserved this behavior
for backward compatibility, but recommend against relying on this behavior.

## Examples

```
> cidrsubnet("172.16.0.0/12", 4, 2)
172.18.0.0/16
> cidrsubnet("10.1.2.0/24", 4, 15)
10.1.2.240/28
> cidrsubnet("fd00:fd12:3456:7890::/56", 16, 162)
fd00:fd12:3456:7800:a200::/72
```

## Netmasks and Subnets

Using `cidrsubnet` requires familiarity with some network addressing concepts.

The most important idea is that an IP address (whether IPv4 or IPv6) is
fundamentally constructed from binary digits, even though we conventionally
represent it as either four decimal octets (for IPv4) or a sequence of 16-bit
hexadecimal numbers (for IPv6).

Taking our example above of `cidrsubnet("10.1.2.0/24", 4, 15)`, the function
will first convert the given IP address string into an equivalent binary
representation:

```
      10 .        1 .        2 .        0
00001010   00000001   00000010 | 00000000
         network               |   host
```

The `/24` at the end of the prefix string specifies that the first 24
bits -- or, the first three octets -- of the address identify the network
while the remaining bits (32 - 24 = 8 bits in this case) identify hosts
within the network.

The CLI tool [`ipcalc`](https://gitlab.com/ipcalc/ipcalc) is useful for
visualizing CIDR prefixes as binary numbers. We can confirm the conversion
above by providing the same prefix string to `ipcalc`:

```
$ ipcalc 10.1.2.0/24
Address:   10.1.2.0             00001010.00000001.00000010. 00000000
Netmask:   255.255.255.0 = 24   11111111.11111111.11111111. 00000000
Wildcard:  0.0.0.255            00000000.00000000.00000000. 11111111
=>
Network:   10.1.2.0/24          00001010.00000001.00000010. 00000000
HostMin:   10.1.2.1             00001010.00000001.00000010. 00000001
HostMax:   10.1.2.254           00001010.00000001.00000010. 11111110
Broadcast: 10.1.2.255           00001010.00000001.00000010. 11111111
Hosts/Net: 254                   Class A, Private Internet
```

This gives us some additional information but also confirms (using a slightly
different notation) the conversion from decimal to binary and shows the range
of possible host addresses in this network.

While [`cidrhost`](/terraform/language/functions/cidrhost) allows calculating single host IP addresses,
`cidrsubnet` on the other hand creates a new network prefix _within_ the given
network prefix. In other words, it creates a subnet.

When we call `cidrsubnet` we also pass two additional arguments: `newbits` and
`netnum`. `newbits` decides how much longer the resulting prefix will be in
bits; in our example here we specified `4`, which means that the resulting
subnet will have a prefix length of 24 + 4 = 28 bits. We can imagine these
bits breaking down as follows:

```
      10 .        1 .        2 .    ?        0
00001010   00000001   00000010 |   XXXX | 0000
         parent network        | netnum | host
```

Four of the eight bits that were originally the "host number" are now being
repurposed as the subnet number. The network prefix no longer falls on an
exact octet boundary, so in effect we are now splitting the last decimal number
in the IP address into two parts, using half of it to represent the subnet
number and the other half to represent the host number.

The `netnum` argument then decides what number value to encode into those
four new subnet bits. In our current example we passed `15`, which is
represented in binary as `1111`, allowing us to fill in the `XXXX` segment
in the above:

```
      10 .        1 .        2 .    15       0
00001010   00000001   00000010 |   1111 | 0000
         parent network        | netnum | host
```

To convert this back into normal decimal notation we need to recombine the
two portions of the final octet. Converting `11110000` from binary to decimal
gives 240, which can then be combined with our new prefix length of 28 to
produce the result `10.1.2.240/28`. Again we can pass this prefix string to
`ipcalc` to visualize it:

```
$ ipcalc 10.1.2.240/28
Address:   10.1.2.240           00001010.00000001.00000010.1111 0000
Netmask:   255.255.255.240 = 28 11111111.11111111.11111111.1111 0000
Wildcard:  0.0.0.15             00000000.00000000.00000000.0000 1111
=>
Network:   10.1.2.240/28        00001010.00000001.00000010.1111 0000
HostMin:   10.1.2.241           00001010.00000001.00000010.1111 0001
HostMax:   10.1.2.254           00001010.00000001.00000010.1111 1110
Broadcast: 10.1.2.255           00001010.00000001.00000010.1111 1111
Hosts/Net: 14                    Class A, Private Internet
```

The new subnet has four bits available for host numbering, which means
that there are 14 host addresses available for assignment once we subtract
the network's own address and the broadcast address. You can thus use
[`cidrhost`](/terraform/language/functions/cidrhost) function to calculate those host addresses by
providing it a value between 1 and 14:

```
> cidrhost("10.1.2.240/28", 1)
10.1.2.241
> cidrhost("10.1.2.240/28", 14)
10.1.2.254
```

For more information on CIDR notation and subnetting, see
[Classless Inter-domain Routing](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing).

## Related Functions

* [`cidrhost`](/terraform/language/functions/cidrhost) calculates the IP address for a single host
  within a given network address prefix.
* [`cidrnetmask`](/terraform/language/functions/cidrnetmask) converts an IPv4 network prefix in CIDR
  notation into netmask notation.
* [`cidrsubnets`](/terraform/language/functions/cidrsubnets) can allocate multiple consecutive
  addresses under a prefix at once, numbering them automatically.

CIDRSUBNETS                                                *terraform-function-cidrsubnets*

https://developer.hashicorp.com/terraform/language/functions/cidrsubnets

---
page_title: cidrsubnets - Functions - Configuration Language
description: |-
  The cidrsubnets function calculates a sequence of consecutive IP address
  ranges within a particular CIDR prefix.
---

# `cidrsubnets` Function

`cidrsubnets` calculates a sequence of consecutive IP address ranges within
a particular CIDR prefix.

```hcl
cidrsubnets(prefix, newbits...)
```

`prefix` must be given in CIDR notation, as defined in
[RFC 4632 section 3.1](https://tools.ietf.org/html/rfc4632#section-3.1).

The remaining arguments, indicated as `newbits` above, each specify the number
of additional network prefix bits for one returned address range. The return
value is therefore a list with one element per `newbits` argument, each
a string containing an address range in CIDR notation.

For more information on IP addressing concepts, see the documentation for the
related function [`cidrsubnet`](/terraform/language/functions/cidrsubnet). `cidrsubnet` calculates
a single subnet address within a prefix while allowing you to specify its
subnet number, while `cidrsubnets` can calculate many at once, potentially of
different sizes, and assigns subnet numbers automatically.

When using this function to partition an address space as part of a network
address plan, you must not change any of the existing arguments once network
addresses have been assigned to real infrastructure, or else later address
assignments will be invalidated. However, you _can_ append new arguments to
existing calls safely, as long as there is sufficient address space available.

This function accepts both IPv6 and IPv4 prefixes, and the result always uses
the same addressing scheme as the given prefix.

-> **Note:** As a historical accident, this function interprets IPv4 address
octets that have leading zeros as decimal numbers, which is contrary to some
other systems which interpret them as octal. We have preserved this behavior
for backward compatibility, but recommend against relying on this behavior.

-> **Note:** [The Terraform module `hashicorp/subnets/cidr`](https://registry.terraform.io/modules/hashicorp/subnets/cidr)
wraps `cidrsubnets` to provide additional functionality for assigning symbolic
names to your networks and skipping prefixes for obsolete allocations. Its
documentation includes usage examples for several popular cloud virtual network
platforms.

## Examples

```
> cidrsubnets("10.1.0.0/16", 4, 4, 8, 4)
[
  "10.1.0.0/20",
  "10.1.16.0/20",
  "10.1.32.0/24",
  "10.1.48.0/20",
]

> cidrsubnets("fd00:fd12:3456:7890::/56", 16, 16, 16, 32)
[
  "fd00:fd12:3456:7800::/72",
  "fd00:fd12:3456:7800:100::/72",
  "fd00:fd12:3456:7800:200::/72",
  "fd00:fd12:3456:7800:300::/88",
]
```

You can use nested `cidrsubnets` calls with
[`for` expressions](/terraform/language/expressions/for)
to concisely allocate groups of network address blocks:

```
> [for cidr_block in cidrsubnets("10.0.0.0/8", 8, 8, 8, 8) : cidrsubnets(cidr_block, 4, 4)]
[
  [
    "10.0.0.0/20",
    "10.0.16.0/20",
  ],
  [
    "10.1.0.0/20",
    "10.1.16.0/20",
  ],
  [
    "10.2.0.0/20",
    "10.2.16.0/20",
  ],
  [
    "10.3.0.0/20",
    "10.3.16.0/20",
  ],
]
```

## Related Functions

* [`cidrhost`](/terraform/language/functions/cidrhost) calculates the IP address for a single host
  within a given network address prefix.
* [`cidrnetmask`](/terraform/language/functions/cidrnetmask) converts an IPv4 network prefix in CIDR
  notation into netmask notation.
* [`cidrsubnet`](/terraform/language/functions/cidrsubnet) calculates a single subnet address, allowing
  you to specify its network number.

COALESCELIST                                               *terraform-function-coalescelist*

https://developer.hashicorp.com/terraform/language/functions/coalescelist

---
page_title: coalescelist - Functions - Configuration Language
description: |-
  The coalescelist function takes any number of list arguments and returns the
  first one that isn't empty.
---

# `coalescelist` Function

`coalescelist` takes any number of list arguments and returns the first one
that isn't empty.

## Examples

```
> coalescelist(["a", "b"], ["c", "d"])
[
  "a",
  "b",
]
> coalescelist([], ["c", "d"])
[
  "c",
  "d",
]
```

To perform the `coalescelist` operation with a list of lists, use the `...`
symbol to expand the outer list as arguments:

```
> coalescelist([[], ["c", "d"]]...)
[
  "c",
  "d",
]
```

## Related Functions

* [`coalesce`](/terraform/language/functions/coalesce) performs a similar operation with string
  arguments rather than list arguments.

COALESCE                                                   *terraform-function-coalesce*

https://developer.hashicorp.com/terraform/language/functions/coalesce

---
page_title: coalesce - Functions - Configuration Language
description: |-
  The coalesce function takes any number of arguments and returns the
  first one that isn't null nor empty.
---

# `coalesce` Function

`coalesce` takes any number of arguments and returns the first one
that isn't null or an empty string.

All of the arguments must be of the same type. Terraform will try to
convert mismatched arguments to the most general of the types that all
arguments can convert to, or return an error if the types are incompatible.
The result type is the same as the type of all of the arguments.

## Examples

```
> coalesce("a", "b")
a
> coalesce("", "b")
b
> coalesce(1,2)
1
```

To perform the `coalesce` operation with a list of strings, use the `...`
symbol to expand the list as arguments:

```
> coalesce(["", "b"]...)
b
```

Terraform attempts to select a result type that all of the arguments can
convert to, so mixing argument types may produce surprising results due to
Terraform's automatic type conversion rules:

```
> coalesce(1, "hello")
"1"
> coalesce(true, "hello")
"true"
> coalesce({}, "hello")

Error: Error in function call

Call to function "coalesce" failed: all arguments must have the same type.
```

## Related Functions

* [`coalescelist`](/terraform/language/functions/coalescelist) performs a similar operation with
  list arguments rather than individual arguments.

COMPACT                                                    *terraform-function-compact*

https://developer.hashicorp.com/terraform/language/functions/compact

---
page_title: compact - Functions - Configuration Language
description: The compact function removes null or empty string elements from a list.
---

# `compact` Function

`compact` takes a list of strings and returns a new list with any null or empty string
elements removed.

## Examples

```
> compact(["a", "", "b", null, "c"])
[
  "a",
  "b",
  "c",
]
```

CONCAT                                                     *terraform-function-concat*

https://developer.hashicorp.com/terraform/language/functions/concat

---
page_title: concat - Functions - Configuration Language
description: The concat function combines two or more lists into a single list.
---

# `concat` Function

`concat` takes two or more lists and combines them into a single list.

## Examples

```
> concat(["a", ""], ["b", "c"])
[
  "a",
  "",
  "b",
  "c",
]

# Can do multiple lists of mixed types, arguments can also be empty lists
concat([], [1, "a"], [[3], "c"])
[
  1,
  "a",
  [
    3,
  ],
  "c",
]
```

CONTAINS                                                   *terraform-function-contains*

https://developer.hashicorp.com/terraform/language/functions/contains

---
page_title: contains - Functions - Configuration Language
description: The contains function determines whether a list or set contains a given value.
---

# `contains` Function

`contains` determines whether the list, tuple, or set given in its first
argument contains at least one element that is equal to the value in the second
argument, using the same definition of equality as the `==` operator described in
[Equality Operators](/terraform/language/expressions/operators#equality-operators).

```hcl
contains(list, value)
```

## Examples

```
> contains(["a", "b", "c"], "a")
true
> contains(["a", "b", "c"], "d")
false
```

CSVDECODE                                                  *terraform-function-csvdecode*

https://developer.hashicorp.com/terraform/language/functions/csvdecode

---
page_title: csvdecode - Functions - Configuration Language
description: The csvdecode function decodes CSV data into a list of maps.
---

# `csvdecode` Function

`csvdecode` decodes a string containing CSV-formatted data and produces a
list of maps representing that data.

CSV is _Comma-separated Values_, an encoding format for tabular data. There
are many variants of CSV, but this function implements the format defined
in [RFC 4180](https://tools.ietf.org/html/rfc4180).

The first line of the CSV data is interpreted as a "header" row: the values
given are used as the keys in the resulting maps. Each subsequent line becomes
a single map in the resulting list, matching the keys from the header row
with the given values by index. All lines in the file must contain the same
number of fields, or this function will produce an error.

## Examples

```
> csvdecode("a,b,c\n1,2,3\n4,5,6")
[
  {
    "a" = "1"
    "b" = "2"
    "c" = "3"
  },
  {
    "a" = "4"
    "b" = "5"
    "c" = "6"
  }
]
```

## Use with the `for_each` meta-argument

You can use the result of `csvdecode` with
[the `for_each` meta-argument](/terraform/language/meta-arguments/for_each)
to describe a collection of similar objects whose differences are
described by the rows in the given CSV file.

There must be one column in the CSV file that can serve as a unique id for each
row, which we can then use as the tracking key for the individual instances in
the `for_each` expression. For example:

```hcl
locals {
  # We've included this inline to create a complete example, but in practice
  # this is more likely to be loaded from a file using the "file" function.
  csv_data = <<-CSV
    local_id,instance_type,ami
    foo1,t2.micro,ami-54d2a63b
    foo2,t2.micro,ami-54d2a63b
    foo3,t2.micro,ami-54d2a63b
    bar1,m3.large,ami-54d2a63b
  CSV

  instances = csvdecode(local.csv_data)
}

resource "aws_instance" "example" {
  for_each = tomap({ for inst in local.instances : inst.local_id => inst })

  instance_type = each.value.instance_type
  ami           = each.value.ami
}
```

The `for` expression in our `for_each` argument transforms the list produced
by `csvdecode` into a map using the `local_id` as a key, which tells
Terraform to use the `local_id` value to track each instance it creates.
Terraform will create and manage the following instance addresses:

- `aws_instance.example["foo1"]`
- `aws_instance.example["foo2"]`
- `aws_instance.example["foo3"]`
- `aws_instance.example["bar1"]`

If you modify a row in the CSV on a subsequent plan, Terraform will interpret
that as an update to the existing object as long as the `local_id` value is
unchanged. If you add or remove rows from the CSV then Terraform will plan to
create or destroy associated instances as appropriate.

If there is no reasonable value you can use as a unique identifier in your CSV
then you could instead use
[the `count` meta-argument](/terraform/language/meta-arguments/count)
to define an object for each CSV row, with each one identified by its index into
the list returned by `csvdecode`. However, in that case any future updates to
the CSV may be disruptive if they change the positions of particular objects in
the list. We recommend using `for_each` with a unique id column to make
behavior more predictable on future changes.

DIRNAME                                                    *terraform-function-dirname*

https://developer.hashicorp.com/terraform/language/functions/dirname

---
page_title: dirname - Functions - Configuration Language
description: The dirname function removes the last portion from a filesystem path.
---

# `dirname` Function

`dirname` takes a string containing a filesystem path and removes the last
portion from it.

This function works only with the path string and does not access the
filesystem itself. It is therefore unable to take into account filesystem
features such as symlinks.

If the path is empty then the result is `"."`, representing the current
working directory.

The behavior of this function depends on the host platform. On Windows systems,
it uses backslash `\` as the path segment separator. On Unix systems, the slash
`/` is used. The result of this function is normalized, so on a Windows system
any slashes in the given path will be replaced by backslashes before returning.

Referring directly to filesystem paths in resource arguments may cause
spurious diffs if the same configuration is applied from multiple systems or on
different host operating systems. We recommend using filesystem paths only
for transient values, such as the argument to [`file`](/terraform/language/functions/file) (where
only the contents are then stored) or in `connection` and `provisioner` blocks.

## Examples

```
> dirname("foo/bar/baz.txt")
foo/bar
```

## Related Functions

* [`basename`](/terraform/language/functions/basename) returns _only_ the last portion of a filesystem
  path, discarding the portion that would be returned by `dirname`.

DISTINCT                                                   *terraform-function-distinct*

https://developer.hashicorp.com/terraform/language/functions/distinct

---
page_title: distinct - Functions - Configuration Language
description: The distinct function removes duplicate elements from a list.
---

# `distinct` Function

`distinct` takes a list and returns a new list with any duplicate elements
removed.

The first occurrence of each value is retained and the relative ordering of
these elements is preserved.

## Examples

```
> distinct(["a", "b", "a", "c", "d", "b"])
[
  "a",
  "b",
  "c",
  "d",
]
```

ELEMENT                                                    *terraform-function-element*

https://developer.hashicorp.com/terraform/language/functions/element

---
page_title: element - Functions - Configuration Language
description: The element function retrieves a single element from a list.
---

# `element` Function

`element` retrieves a single element from a list.

```hcl
element(list, index)
```

The index is zero-based. This function produces an error if used with an
empty list. The index can be a negative integer.

Use the built-in index syntax `list[index]` in most cases. Use this function
only for the special additional "wrap-around" behavior described below.

## Examples

```
> element(["a", "b", "c"], 1)
"b"
```

If the given index is greater than the length of the list then the index is
"wrapped around" by taking the index modulo the length of the list:

```
> element(["a", "b", "c"], 3)
"a"
```

To get the last element from the list use the index `-1`:

```
> element(["a", "b", "c"], -1)
"c"
```

## Related Functions

* [`index`](/terraform/language/functions/index_function) finds the index for a particular element value.
* [`lookup`](/terraform/language/functions/lookup) retrieves a value from a _map_ given its _key_.

ENDSWITH                                                   *terraform-function-endswith*

https://developer.hashicorp.com/terraform/language/functions/endswith

---
page_title: endswith - Functions - Configuration Language
description: |-
  The endswith function takes two values: a string to check and a suffix string. It returns true if the first string ends with that exact suffix.
---

# `endswith` Function

`endswith` takes two values: a string to check and a suffix string. The function returns true if the first string ends with that exact suffix.

```hcl
endswith(string, suffix)
```

## Examples

```
> endswith("hello world", "world")
true

> endswith("hello world", "hello")
false
```

## Related Functions

- [`startswith`](/terraform/language/functions/startswith) takes two values: a string to check and a prefix string. The function returns true if the string begins with that exact prefix.

EPHEMERALASNULL                                            *terraform-function-ephemeralasnull*

https://developer.hashicorp.com/terraform/language/functions/ephemeralasnull

---
page_title: ephemeralasnull function reference - Functions - Configuration Language  
description: |-  
  The `ephemeralasnull` function accepts an ephemeral value and returns null.  
---

# `ephemeralasnull` function reference

-> **Note**: The `ephemeralasnull` function is available in Terraform v1.10 and later.

This topic provides reference information about the `ephemeralasnull` function. The `ephemeralasnull` function accepts an ephemeral value and returns `null`. 

## Introduction

You can use the `ephemeralasnull` function to nullify ephemeral values. For example, if you pass an object with a nested ephemeral value to `ephemeralasnull`,it nullifies any ephemeral values within that object.

## Syntax

Use the `ephemeralasnull` function with the following syntax:

```hcl
ephemeralasnull(var.my_ephemeral_value)
```

In the following example, you can pass the `ephemeralasnull` function an ephemeral value, and the function returns `null`:

```hcl
variable "example" {
  type      = string
  default   = "test"
  ephemeral = true
}

# This output returns null.
output "example_output" {
  value       = ephemeralasnull(var.example)
}
```

For more information on which Terraform blocks can be ephemeral, refer to ephemeral [inputs](/terraform/language/values/variables#exclude-values-from-state), [outputs](/terraform/language/values/outputs#ephemeral-avoid-storing-values-in-state-or-plan-files), and [resources](/terraform/language/resources/ephemeral).

## Example use case

The following example shows how you can use the  `ephemeralasnull` function to intake a map that contains some ephemeral values, and output the values that are not ephemeral.

```hcl
variable "session_token" {
  type      = string
  default   = "test"
  ephemeral = true
}

variable "configuration" {
  type = map(string)
  default = {
    "env" = "development"
  }
}

# This is a contrived example, but this pattern works with any object that is a mix of ephemeral and non-ephemeral values. 
locals {
  configuration_with_token = merge(
    var.configuration,
    { "session_token" = var.session_token }
  )
  ephemeral = true
}

output "configuration_settings" {
# Using ephemeralasnull enables you to output the non-ephemeral values.
  value       = ephemeralasnull(local.things_with_token)
  description = "Environment setting."
}
```

When you apply the above configuration, Terraform returns the `ephemeral` values in `locals.configuration_settings` as `null`. This lets you output the non-ephemeral value `env`.

```hcl
Outputs:

configuration_settings = {
  "env" = "development"
  "session_token" = tostring(null)
}
```
FILEBASE64                                                 *terraform-function-filebase64*

https://developer.hashicorp.com/terraform/language/functions/filebase64

---
page_title: filebase64 - Functions - Configuration Language
description: |-
  The filebase64 function reads the contents of the file at the given path and
  returns them as a base64-encoded string.
---

# `filebase64` Function

`filebase64` reads the contents of a file at the given path and returns them as
a base64-encoded string.

```hcl
filebase64(path)
```

The result is a Base64 representation of the raw bytes in the given file.
Strings in the Terraform language are sequences of Unicode characters, so
Base64 is the standard way to represent raw binary data that cannot be
interpreted as Unicode characters. Resource types that operate on binary
data will accept this data encoded in Base64, thus avoiding the need to
decode the result of this function.

Terraform uses the "standard" Base64 alphabet as defined in
[RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).

This function can be used only with functions that already exist as static
files on disk at the beginning of a Terraform run. Language functions do not
participate in the dependency graph, so this function cannot be used with
files that are generated dynamically during a Terraform operation.

## Examples

```
> filebase64("${path.module}/hello.txt")
SGVsbG8gV29ybGQ=
```

## Related Functions

* [`file`](/terraform/language/functions/file) also reads the contents of a given file,
  but interprets the data as UTF-8 text and returns the result directly
  as a string, without any further encoding.
* [`base64decode`](/terraform/language/functions/base64decode) can decode a Base64 string representing
  bytes in UTF-8, but in practice `base64decode(filebase64(...))` is equivalent
  to the shorter expression `file(...)`.

FILEBASE64SHA256                                           *terraform-function-filebase64sha256*

https://developer.hashicorp.com/terraform/language/functions/filebase64sha256

---
page_title: filebase64sha256 - Functions - Configuration Language
description: |-
  The filebase64sha256 function computes the SHA256 hash of the contents of
  a given file and encodes it with Base64.
---

# `filebase64sha256` Function

`filebase64sha256` is a variant of [`base64sha256`](/terraform/language/functions/base64sha256)
that hashes the contents of a given file rather than a literal string.

This is similar to `base64sha256(file(filename))`, but
because [`file`](/terraform/language/functions/file) accepts only UTF-8 text it cannot be used to
create hashes for binary files.

FILEBASE64SHA512                                           *terraform-function-filebase64sha512*

https://developer.hashicorp.com/terraform/language/functions/filebase64sha512

---
page_title: filebase64sha512 - Functions - Configuration Language
description: |-
  The filebase64sha512 function computes the SHA512 hash of the contents of
  a given file and encodes it with Base64.
---

# `filebase64sha512` Function

`filebase64sha512` is a variant of [`base64sha512`](/terraform/language/functions/base64sha512)
that hashes the contents of a given file rather than a literal string.

This is similar to `base64sha512(file(filename))`, but
because [`file`](/terraform/language/functions/file) accepts only UTF-8 text it cannot be used to
create hashes for binary files.

FILEEXISTS                                                 *terraform-function-fileexists*

https://developer.hashicorp.com/terraform/language/functions/fileexists

---
page_title: fileexists - Functions - Configuration Language
description: The fileexists function determines whether a file exists at a given path.
---

# `fileexists` Function

`fileexists` determines whether a file exists at a given path.

```hcl
fileexists(path)
```

Functions are evaluated during configuration parsing rather than at apply time,
so this function can only be used with files that are already present on disk
before Terraform takes any actions.

This function works only with regular files. If used with a directory, FIFO,
or other special mode, it will return an error.

## Examples

```
> fileexists("${path.module}/hello.txt")
true
```

```hcl
fileexists("custom-section.sh") ? file("custom-section.sh") : local.default_content
```

## Related Functions

* [`file`](/terraform/language/functions/file) reads the contents of a file at a given path

FILEMD5                                                    *terraform-function-filemd5*

https://developer.hashicorp.com/terraform/language/functions/filemd5

---
page_title: filemd5 - Functions - Configuration Language
description: |-
  The filemd5 function computes the MD5 hash of the contents of
  a given file and encodes it as hex.
---

# `filemd5` Function

`filemd5` is a variant of [`md5`](/terraform/language/functions/md5)
that hashes the contents of a given file rather than a literal string.

This is similar to `md5(file(filename))`, but
because [`file`](/terraform/language/functions/file) accepts only UTF-8 text it cannot be used to
create hashes for binary files.

Collision attacks have been successfully performed against this hashing
function. Before using this function for anything security-sensitive, refer to
[RFC 6151](https://tools.ietf.org/html/rfc6151) for updated security
considerations applying to the MD5 algorithm.

FILE                                                       *terraform-function-file*

https://developer.hashicorp.com/terraform/language/functions/file

---
page_title: file - Functions - Configuration Language
description: |-
  The file function reads the contents of the file at the given path and
  returns them as a string.
---

# `file` Function

`file` reads the contents of a file at the given path and returns them as
a string.

```hcl
file(path)
```

Strings in the Terraform language are sequences of Unicode characters, so
this function will interpret the file contents as UTF-8 encoded text and
return the resulting Unicode characters. If the file contains invalid UTF-8
sequences then this function will produce an error.

This function can be used only with files that already exist on disk
at the beginning of a Terraform run. Functions do not participate in the
dependency graph, so this function cannot be used with files that are generated
dynamically during a Terraform operation. We do not recommend using dynamic
local files in Terraform configurations, but in rare situations where this is
necessary you can use
[the `local_file` data source](https://registry.terraform.io/providers/hashicorp/local/latest/docs/data-sources/file)
to read files while respecting resource dependencies.

## Examples

```
> file("${path.module}/hello.txt")
Hello World
```

## Related Functions

* [`filebase64`](/terraform/language/functions/filebase64) also reads the contents of a given file,
  but returns the raw bytes in that file Base64-encoded, rather than
  interpreting the contents as UTF-8 text.
* [`fileexists`](/terraform/language/functions/fileexists) determines whether a file exists
  at a given path.
* [`templatefile`](/terraform/language/functions/templatefile) renders using a file from disk as a
  template.

FILESET                                                    *terraform-function-fileset*

https://developer.hashicorp.com/terraform/language/functions/fileset

---
page_title: fileset - Functions - Configuration Language
description: The fileset function enumerates a set of regular file names given a pattern.
---

# `fileset` Function

`fileset` enumerates a set of regular file names given a path and pattern.
The path is automatically removed from the resulting set of file names and any
result still containing path separators always returns forward slash (`/`) as
the path separator for cross-system compatibility.

```hcl
fileset(path, pattern)
```

Supported pattern matches:

- `*` - matches any sequence of non-separator characters
- `**` - matches any sequence of characters, including separator characters
- `?` - matches any single non-separator character
- `{alternative1,...}` - matches a sequence of characters if one of the comma-separated alternatives matches
- `[CLASS]` - matches any single non-separator character inside a class of characters (see below)
- `[^CLASS]` - matches any single non-separator character outside a class of characters (see below)

Note that the doublestar (`**`) must appear as a path component by itself. A
pattern such as /path\*\* is invalid and will be treated the same as /path\*, but
/path\*/\*\* should achieve the desired result.

Character classes support the following:

- `[abc]` - matches any single character within the set
- `[a-z]` - matches any single character within the range

Functions are evaluated during configuration parsing rather than at apply time,
so this function can only be used with files that are already present on disk
before Terraform takes any actions.

## Examples

```
> fileset(path.module, "files/*.txt")
[
  "files/hello.txt",
  "files/world.txt",
]

> fileset(path.module, "files/{hello,world}.txt")
[
  "files/hello.txt",
  "files/world.txt",
]

> fileset("${path.module}/files", "*")
[
  "hello.txt",
  "world.txt",
]

> fileset("${path.module}/files", "**")
[
  "hello.txt",
  "world.txt",
  "subdirectory/anotherfile.txt",
]
```

A common use of `fileset` is to create one resource instance per matched file, using
[the `for_each` meta-argument](/terraform/language/meta-arguments/for_each):

```hcl
resource "example_thing" "example" {
  for_each = fileset(path.module, "files/*")

  # other configuration using each.value
}
```

FILESHA1                                                   *terraform-function-filesha1*

https://developer.hashicorp.com/terraform/language/functions/filesha1

---
page_title: filesha1 - Functions - Configuration Language
description: The filesha1 function computes the SHA1 hash of the contents of a given file and encodes it as hex.
---

# `filesha1` function reference
This topic provides reference information about the `filesha1` function, which calculates the SHA-1 hash of a file's contents. 

## Introduction

The `filesha1` is a variant of [`sha1`](/terraform/language/functions/sha1) that hashes the contents of a given file rather than a literal string. 

Use the `filesha1` function instead of wrapping the `file` function in a `sha1` function, for example `sha1(file(filename))`, because [`file`](/terraform/language/functions/file) accepts only UTF-8 text. As a result, you cannot use `sha1(file(filename))` to create hashes for binary files.

!> **Security warning**: This hashing function is susceptible to collision attacks. Before using this function for anything security-sensitive, review relevant literature to understand the security implications.

## Syntax

Use the filesha1 function with the following syntax:

```hcl
filesha1(path) 
```

The `path` is the relative or absolute file path to the file whose SHA-1 hash you want to compute.

In the following example, the function returns the SHA-1 value.

```hcl
$ filesha1("example.txt")
d3486ae9136e7856bc42212385ea797094475802
```

## Example use case

In the following example the `filesha1` function computes the SHA-1 hash of the file `example.txt` located in the current module's directory. The result is a 40-character hexadecimal string representing the SHA-1 hash.

```hcl
output "file_hash" { 
  value = filesha1("${path.module}/example.txt") 
}
```

## Related functions

- [`sha1`](/terraform/language/functions/sha1) computes the SHA-1 hash of a given string and encodes it with hexadecimal digits.
- [`filesha256`](/terraform/language/functions/filesha256) computes the SHA-256 hash of a given file and encodes it with hexadecimal digits.
- [`filesha512`](/terraform/language/functions/filesha512) computes the SHA-512 hash of a given file and encodes it with hexadecimal digits.

FILESHA256                                                 *terraform-function-filesha256*

https://developer.hashicorp.com/terraform/language/functions/filesha256

---
page_title: filesha256 - Functions - Configuration Language
description: |-
  The filesha256 function computes the SHA256 hash of the contents of
  a given file and encodes it as hex.
---

# `filesha256` function reference

This topic provides reference information about the `filesha256` function, which calculates the SHA-256 hash of a file's contents. 

## Introduction

The `filesha256` is a variant of [`sha256`](/terraform/language/functions/sha256)
that hashes the contents of a given file rather than a literal string.

Use the `filesha1` function instead of wrapping the `file` function in a `sha1` function, for example `sha1(file(filename))`, because [`file`](/terraform/language/functions/file) accepts only UTF-8 text. As a result, you cannot use `sha1(file(filename))` to create hashes for binary files.

## Syntax

Use the `filesha256` function with the following syntax:

```hcl
filesha256(path)
```

The `path` is the relative or absolute file path to the file whose SHA-256 hash you want to compute.

In the following example, the function returns the SHA-256 value of `example.txt`.

```hcl
$ filesha512("example.txt")
a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b0b571d0f6a26f2bb
```

## Example use case

In the following example, the `filesha256` function computes the SHA-256 hash of the file `example.txt` located in the current module's directory.

```hcl
output "file_hash" {
  value = filesha256("example.txt")
}
```

## Related functions

- [`sha256`](/terraform/language/functions/sha256) computes the SHA-1 hash of a given string and encodes it with hexadecimal digits.
- [`filesha512`](/terraform/language/functions/filesha512) computes the SHA-512 hash of a given file and encodes it with hexadecimal digits.
- [`filesha1`](/terraform/language/functions/filesha1)computes the SHA-1 hash of a given file and encodes it with hexadecimal digits.

FILESHA512                                                 *terraform-function-filesha512*

https://developer.hashicorp.com/terraform/language/functions/filesha512

---
page_title: filesha512 - Functions - Configuration Language
description: |-
  The filesha512 function computes the SHA512 hash of the contents of
  a given file and encodes it as hex.
---

# `filesha512` function reference

This topic provides reference information about the `filesha512` function, which calculates the SHA-512 hash of a file's contents. 

## Introduction

The `filesha512` is a variant of [`sha512`](/terraform/language/functions/sha512)
that hashes the contents of a given file rather than a literal string.

This is similar to `sha512(file(filename))`, but
because [`file`](/terraform/language/functions/file) accepts only UTF-8 text it cannot be used to
create hashes for binary files.

## Syntax

Use the `filesha512` function with the following syntax:

```hcl
filesha512(path)
```

The `path` is the relative or absolute file path to the file whose SHA-512 hash you want to compute.

In the following example, the function returns the SHA-512 value of `example.txt`.

```hcl
$ filesha512("example.txt")
861844d6704e8573fec34d967e20bcfe6e061b3348b3b0c7e9b7c6a482f6f15a48bffd0fb928fd8c9f9196f7a8596d5e32b45d5a25488a8499396a67442c1d76
```

## Example use case

In the following example, the `filesha512` function computes the SHA-512 hash of the file `example.txt` located in the current module's directory.

```hcl
output "file_hash" {
  value = filesha512("example.txt")
}
```

## Related functions

- [`sha512`](/terraform/language/functions/sha512) computes the SHA-512 hash of a given string and encodes it with hexadecimal digits.
- [`filesha256`](/terraform/language/functions/filesha256) computes the SHA-1 hash of a given file and encodes it with hexadecimal digits.
- [`filesha1`](/terraform/language/functions/filesha1)computes the SHA-1 hash of a given file and encodes it with hexadecimal digits.

FLATTEN                                                    *terraform-function-flatten*

https://developer.hashicorp.com/terraform/language/functions/flatten

---
page_title: flatten - Functions - Configuration Language
description: The flatten function eliminates nested lists from a list.
---

# `flatten` Function

`flatten` takes a list and replaces any elements that are lists with a
flattened sequence of the list contents.

## Examples

```
> flatten([["a", "b"], [], ["c"]])
["a", "b", "c"]
```

If any of the nested lists also contain directly-nested lists, these too are
flattened recursively:

```
> flatten([[["a", "b"], []], ["c"]])
["a", "b", "c"]
```

Indirectly-nested lists, such as those in maps, are _not_ flattened.

## Flattening nested structures for `for_each`

The
[resource `for_each`](/terraform/language/meta-arguments/for_each)
and
[`dynamic` block](/terraform/language/expressions/dynamic-blocks)
language features both require a collection value that has one element for
each repetition.

Sometimes your input data structure isn't naturally in a suitable shape for
use in a `for_each` argument, and `flatten` can be a useful helper function
when reducing a nested data structure into a flat one.

For example, consider a module that declares a variable like the following:

```hcl
variable "networks" {
  type = map(object({
    cidr_block = string
    subnets    = map(object({ cidr_block = string }))
  }))
  default = {
    "private" = {
      cidr_block = "10.1.0.0/16"
      subnets = {
        "db1" = {
          cidr_block = "10.1.0.0/24"
        }
        "db2" = {
          cidr_block = "10.1.1.0/24"
        }
      }
    },
    "public" = {
      cidr_block = "10.2.0.0/16"
      subnets = {
        "webserver" = {
          cidr_block = "10.2.1.0/24"
        }
        "email_server" = {
          cidr_block = "10.2.2.0/24"
        }
      }
    }
    "dmz" = {
      cidr_block = "10.3.0.0/16"
      subnets = {
        "firewall" = {
          cidr_block = "10.3.1.0/24"
        }
      }
    }
  }
}

```

The above is a reasonable way to model objects that naturally form a tree,
such as top-level networks and their subnets. The repetition for the top-level
networks can use this variable directly, because it's already in a form
where the resulting instances match one-to-one with map elements:

```hcl
resource "aws_vpc" "example" {
  for_each = var.networks

  cidr_block = each.value.cidr_block
}
```

However, in order to declare all of the _subnets_ with a single `resource`
block, we must first flatten the structure to produce a collection where each
top-level element represents a single subnet:

```hcl
locals {
  # flatten ensures that this local value is a flat list of objects, rather
  # than a list of lists of objects.
  network_subnets = flatten([
    for network_key, network in var.networks : [
      for subnet_key, subnet in network.subnets : {
        network_key = network_key
        subnet_key  = subnet_key
        network_id  = aws_vpc.example[network_key].id
        cidr_block  = subnet.cidr_block
      }
    ]
  ])
}

resource "aws_subnet" "example" {
  # local.network_subnets is a list, so we must now project it into a map
  # where each key is unique. We'll combine the network and subnet keys to
  # produce a single unique key per instance.
  for_each = tomap({
    for subnet in local.network_subnets : "${subnet.network_key}.${subnet.subnet_key}" => subnet
  })

  vpc_id            = each.value.network_id
  availability_zone = each.value.subnet_key
  cidr_block        = each.value.cidr_block
}
```

The above results in one subnet instance per subnet object, while retaining
the associations between the subnets and their containing networks.

## Related Functions

* [`setproduct`](/terraform/language/functions/setproduct) finds all of the combinations of multiple
  lists or sets of values, which can also be useful when preparing collections
  for use with `for_each` constructs.

FLOOR                                                      *terraform-function-floor*

https://developer.hashicorp.com/terraform/language/functions/floor

---
page_title: floor - Functions - Configuration Language
description: |-
  The floor function returns the closest whole number less than or equal to
  the given value.
---

# `floor` Function

`floor` returns the closest whole number that is less than or equal to the
given value, which may be a fraction.

## Examples

```
> floor(5)
5
> floor(4.9)
4
```

## Related Functions

* [`ceil`](/terraform/language/functions/ceil), which rounds to the nearest whole number _greater than_
  or equal.

FORMATDATE                                                 *terraform-function-formatdate*

https://developer.hashicorp.com/terraform/language/functions/formatdate

---
page_title: formatdate - Functions - Configuration Language
description: The formatdate function converts a timestamp into a different time format.
---

# `formatdate` Function

`formatdate` converts a timestamp into a different time format.

```hcl
formatdate(spec, timestamp)
```

In the Terraform language, timestamps are conventionally represented as
strings using [RFC 3339](https://tools.ietf.org/html/rfc3339)
"Date and Time format" syntax. `formatdate` requires the `timestamp` argument
to be a string conforming to this syntax.

## Examples

```
> formatdate("DD MMM YYYY hh:mm ZZZ", "2018-01-02T23:12:01Z")
02 Jan 2018 23:12 UTC
> formatdate("EEEE, DD-MMM-YY hh:mm:ss ZZZ", "2018-01-02T23:12:01Z")
Tuesday, 02-Jan-18 23:12:01 UTC
> formatdate("EEE, DD MMM YYYY hh:mm:ss ZZZ", "2018-01-02T23:12:01-08:00")
Tue, 02 Jan 2018 23:12:01 -0800
> formatdate("MMM DD, YYYY", "2018-01-02T23:12:01Z")
Jan 02, 2018
> formatdate("HH:mmaa", "2018-01-02T23:12:01Z")
11:12pm
```

## Specification Syntax

The format specification is a string that includes formatting sequences from
the following table. This function is intended for producing common
_machine-oriented_ timestamp formats such as those defined in RFC822, RFC850,
and RFC1123. It is not suitable for truly human-oriented date formatting
because it is not locale-aware. In particular, it can produce month and day
names only in English.

The specification may contain the following sequences:

| Sequence | Result                                                                  |
| -------- | ----------------------------------------------------------------------- |
| `YYYY`   | Four (or more) digit year, like "2006".                                 |
| `YY`     | The year modulo 100, zero padded to at least two digits, like "06".     |
| `MMMM`   | English month name unabbreviated, like "January".                       |
| `MMM`    | English month name abbreviated to three letters, like "Jan".            |
| `MM`     | Month number zero-padded to two digits, like "01" for January.          |
| `M`      | Month number with no padding, like "1" for January.                     |
| `DD`     | Day of month number zero-padded to two digits, like "02".               |
| `D`      | Day of month number with no padding, like "2".                          |
| `EEEE`   | English day of week name unabbreviated, like "Monday".                  |
| `EEE`    | English day of week name abbreviated to three letters, like "Mon".      |
| `hh`     | 24-hour number zero-padded to two digits, like "02".                    |
| `h`      | 24-hour number unpadded, like "2".                                      |
| `HH`     | 12-hour number zero-padded to two digits, like "02".                    |
| `H`      | 12-hour number unpadded, like "2".                                      |
| `AA`     | Hour AM/PM marker in uppercase, like "AM".                              |
| `aa`     | Hour AM/PM marker in lowercase, like "am".                              |
| `mm`     | Minute within hour zero-padded to two digits, like "05".                |
| `m`      | Minute within hour unpadded, like "5".                                  |
| `ss`     | Second within minute zero-padded to two digits, like "09".              |
| `s`      | Second within minute, like "9".                                         |
| `ZZZZZ`  | Timezone offset with colon separating hours and minutes, like "-08:00". |
| `ZZZZ`   | Timezone offset with just sign and digit, like "-0800".                 |
| `ZZZ`    | Like `ZZZZ` but with a special case "UTC" for UTC.                      |
| `Z`      | Like `ZZZZZ` but with a special case "Z" for UTC.                       |

Any non-letter characters, such as punctuation, are reproduced verbatim in the
output. To include literal letters in the format string, enclose them in single
quotes `'`. To include a literal quote, escape it by doubling the quotes.

```
> formatdate("h'h'mm", "2018-01-02T23:12:01-08:00")
23h12
> formatdate("H 'o''clock'", "2018-01-02T23:12:01-08:00")
11 o'clock
```

This format specification syntax is intended to make it easy for a reader
to guess which format will result even if they are not experts on the syntax.
Therefore there are no predefined shorthands for common formats, but format
strings for various RFC-specified formats are given below to be copied into your
configuration as needed:

- [RFC 822](https://tools.ietf.org/html/rfc822#section-5) and
  [RFC RFC 2822](https://tools.ietf.org/html/rfc2822#section-3.3):
  `"DD MMM YYYY hh:mm ZZZ"`
- [RFC 850](https://tools.ietf.org/html/rfc850#section-2.1.4):
  `"EEEE, DD-MMM-YY hh:mm:ss ZZZ"`
- [RFC 1123](https://tools.ietf.org/html/rfc1123#section-5.2.14):
  `"EEE, DD MMM YYYY hh:mm:ss ZZZ"`
- [RFC 3339](https://tools.ietf.org/html/rfc3339):
  `"YYYY-MM-DD'T'hh:mm:ssZ"` (but this is also the input format, so such a
  conversion is redundant.)

## Related Functions

- [`format`](/terraform/language/functions/format) is a more general formatting function for arbitrary
  data.
- [`timestamp`](/terraform/language/functions/timestamp) returns the current date and time in a format
  suitable for input to `formatdate`.

FORMATLIST                                                 *terraform-function-formatlist*

https://developer.hashicorp.com/terraform/language/functions/formatlist

---
page_title: formatlist - Functions - Configuration Language
description: |-
  The formatlist function produces a list of strings by formatting a number of
  other values according to a specification string.
---

# `formatlist` Function

`formatlist` produces a list of strings by formatting a number of other
values according to a specification string.

```hcl
formatlist(spec, values...)
```

The specification string uses
[the same syntax as `format`](/terraform/language/functions/format#specification-syntax).

The given values can be a mixture of list and non-list arguments. Any given
lists must be the same length, which decides the length of the resulting list.

The list arguments are iterated together in order by index, while the non-list
arguments are used repeatedly for each iteration. The format string is evaluated
once per element of the list arguments.

## Examples

```
> formatlist("Hello, %s!", ["Valentina", "Ander", "Olivia", "Sam"])
[
  "Hello, Valentina!",
  "Hello, Ander!",
  "Hello, Olivia!",
  "Hello, Sam!",
]
> formatlist("%s, %s!", "Salutations", ["Valentina", "Ander", "Olivia", "Sam"])
[
  "Salutations, Valentina!",
  "Salutations, Ander!",
  "Salutations, Olivia!",
  "Salutations, Sam!",
]
```

## Related Functions

* [`format`](/terraform/language/functions/format) defines the specification syntax used by this
  function and produces a single string as its result.

FORMAT                                                     *terraform-function-format*

https://developer.hashicorp.com/terraform/language/functions/format

---
page_title: format - Functions - Configuration Language
description: |-
  The format function produces a string by formatting a number of other values
  according to a specification string.
---

# `format` Function

The `format` function produces a string by formatting a number of other values according
to a specification string. It is similar to the `printf` function in C, and
other similar functions in other programming languages.

```hcl
format(spec, values...)
```

## Examples

```
> format("Hello, %s!", "Ander")
Hello, Ander!
> format("There are %d lights", 4)
There are 4 lights
```

Simple format verbs like `%s` and `%d` behave similarly to template
interpolation syntax, which is often more readable.

```
> format("Hello, %s!", var.name)
Hello, Valentina!
> "Hello, ${var.name}!"
Hello, Valentina!
```

We can specify an argument position number

```
> format("%[1]s%[2]s%[1]s%[3]s", "/", "path", "file.tf")
"/path/file.tf"
```

The formatting verb `%#v` accepts a value of any type and presents it using JSON encoding, similar to jsonencode. This can be useful for describing the values given to a module in [custom condition check](/terraform/language/expressions/custom-conditions#error-messages) error messages.

```
> format("%#v", "hello")
"\"hello\""
> format("%#v", true)
"true"
> format("%#v", 1)
"1"
> format("%#v", {a = 1})
"{\"a\":1}"
> format("%#v", [true])
"[true]"
> format("%#v", null)
"null"
```

The `format` function is most useful when you use more complex format specifications.

## Specification Syntax

The specification is a string that includes formatting verbs that are introduced
with the `%` character. The function call must then have one additional argument
for each verb sequence in the specification. The verbs are matched with
consecutive arguments and formatted as directed, as long as each given argument
is convertible to the type required by the format verb.

By default, `%` sequences consume successive arguments starting with the first.
Introducing a `[n]` sequence immediately before the verb letter, where `n` is a
decimal integer, explicitly chooses a particular value argument by its
one-based index. Subsequent calls without an explicit index will then proceed
with `n`+1, `n`+2, etc.

The function produces an error if the format string requests an impossible
conversion or access more arguments than are given. An error is produced also
for an unsupported format verb.

### Verbs

The specification may contain the following verbs.

| Verb  | Result                                                                                    |
| ----- | ----------------------------------------------------------------------------------------- |
| `%%`  | Literal percent sign, consuming no value.                                                 |
| `%v`  | Default formatting based on the [value type](#default-format-verbs). Accepts all types, including items of `null`, `list`, and `map` types.                           |
| `%#v` | JSON serialization of the value, as with `jsonencode`. Accepts all types, including items of `null`, `list`, and `map` types.  |
| `%t`  | Convert to boolean and produce `true` or `false`.                                         |
| `%b`  | Convert to integer number and produce binary representation.                              |
| `%d`  | Convert to integer number and produce decimal representation.                             |
| `%o`  | Convert to integer number and produce octal representation.                               |
| `%x`  | Convert to integer number and produce hexadecimal representation with lowercase letters.  |
| `%X`  | Like `%x`, but use uppercase letters.                                                     |
| `%e`  | Convert to number and produce scientific notation, like `-1.234456e+78`.                  |
| `%E`  | Like `%e`, but use an uppercase `E` to introduce the exponent.                            |
| `%f`  | Convert to number and produce decimal fraction notation with no exponent, like `123.456`. |
| `%g`  | Like `%e` for large exponents or like `%f` otherwise.                                     |
| `%G`  | Like `%E` for large exponents or like `%f` otherwise.                                     |
| `%s`  | Convert to string and insert the string's characters.                                     |
| `%q`  | Convert to string and produce a JSON quoted string representation.                        |

### Default Format Verbs

When `%v` is used, Terraform chooses the appropriate format verb based on the value type.

| Type      | Verb  |
| --------- | ----- |
| `string`  | `%s`  |
| `number`  | `%g`  |
| `bool`    | `%t`  |
| any other | `%#v` |

Null values produce the string `null` if formatted with `%v` or `%#v`, and cause an error for other verbs.

### Width Modifier

Use a width modifier with an optional decimal number immediately
preceding the verb letter to specify how many characters will be used to represent the value. You can specify precision after the (optional) width with a period (`.`) followed by a decimal number. If width or precision are omitted, Terraform selects default values based on the given value.

The following examples demonstrate example use cases for the width modifier.

| Sequence | Result                       |
| -------- | ---------------------------- |
| `%f`     | Default width and precision. |
| `%9f`    | Width 9, default precision.  |
| `%.2f`   | Default width, precision 2.  |
| `%9.2f`  | Width 9, precision 2.        |

-> **Note:** Width and precision modifiers with non-numeric types such as
strings (`%s`) are interpreted differently. Setting either width or precision to
zero is the same as not including them at all.

### Additional Format Options

Use the following symbols immediately after the `%` symbol to set additional formatting requirements.

| Symbol | Result                                                         |
| ------ | -------------------------------------------------------------- |
| space  | Leave a space where the sign would be if a number is positive. |
| `+`    | Show the sign of a number even if it is positive.              |
| `-`    | Pad the width with spaces on the right rather than the left.   |
| `0`    | Pad the width with leading zeros rather than spaces.           |


## Related Functions

* [`formatdate`](/terraform/language/functions/formatdate) is a specialized formatting function for
  human-readable timestamps.
* [`formatlist`](/terraform/language/functions/formatlist) uses the same specification syntax to
  produce a list of strings.

INDENT                                                     *terraform-function-indent*

https://developer.hashicorp.com/terraform/language/functions/indent

---
page_title: indent - Functions - Configuration Language
description: |-
  The indent function adds spaces to the beginning of each line but the first in a multi-line string.
---

# `indent` function reference

This topic provides reference information about the `indent` function.
You can use the `indent` function to add indentation to the beginning of each line, except the first, in a multi-line string.

## Introduction

The `indent` function adds a specified number of spaces to the beginning of each line in a multi-line string, except for the first line.
You can use the `indent` function to help ensure that complex strings are properly formatted, consistent, and readable.
The function can be especially useful when you work with YAML, JSON, Kubernetes, or other formats that require complex, structured text.

## Syntax

Use the `indent` function with the following syntax:

```hcl
indent(num_spaces, string)
```

- The first argument is numeric. It specifies the number of spaces you want to add to each line except the first.
- The second argument is a string. It specifies the multi-line string to which you want to add spaces.

In the following example, the `indent` function adds two spaces to the beginning of each line of the `description` variable to make it easier to read:

```hcl
output "formatted_description" {
  value = indent(2, var.description)
}
```

INDEX_FUNCTION                                             *terraform-function-index_function*

https://developer.hashicorp.com/terraform/language/functions/index_function

---
page_title: index - Functions - Configuration Language
description: The index function finds the element index for a given value in a list.
---

# `index` Function

`index` finds the first element index for a given value in a list.

```hcl
index(list, value)
```

The returned index is zero-based. This function produces an error if the given
value is not present in the list.

## Examples

```
> index(["a", "b", "c"], "b")
1
```

In this example, the index of the first occurence of `"two"` is returned.

```
> index(["one", "two", "two"], "two")
1
```

## Related Functions

* [`element`](/terraform/language/functions/element) retrieves a particular element from a list given
  its index.

INDEX                                                      *terraform-function-index*

https://developer.hashicorp.com/terraform/language/functions/index

---
page_title: Functions - Configuration Language
description: >-
  An introduction to the built-in functions that you can use to transform and
  combine values in expressions.
---

# Built-in Functions

> **Hands-on:** Try the [Perform Dynamic Operations with Functions](/terraform/tutorials/configuration-language/functions?utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS) tutorial.

The Terraform language includes a number of built-in functions that you can
call from within expressions to transform and combine values. The general
syntax for function calls is a function name followed by comma-separated
arguments in parentheses:

```hcl
max(5, 12, 9)
```

For more details on syntax, see
[_Function Calls_](/terraform/language/expressions/function-calls)
in the Expressions section.

# Provider-defined Functions

You cannot define your own functions in the Terraform configuration language, but
you can develop your own providers that expose functions. Refer to
[Provider-defined functions](/terraform/plugin/framework/functions)
for information about defining functions in custom providers.

When using a provider-specific function, add the `provider::<local-name>::` where
`<local-name>` corresponds with an entry in the `required_providers` block.
The following example calls the `encode_tfvars` function in the `terraform` provider:

```hcl
provider::terraform::encode_tfvars({
  example = "Hello!"
})
```

The documentation covers the built-in functions and built-in provider-defined functions only.

Functions defined by external providers are documented by those providers
in the [Terraform Registry](https://registry.terraform.io/browse/providers).

# Experimenting with Functions

You can experiment with the behavior of Terraform's built-in functions from
the Terraform expression console, by running
[the `terraform console` command](/terraform/cli/commands/console):

```
> max(5, 12, 9)
12
```

The examples in the documentation for each function use console output to
illustrate the result of calling the function with different parameters.

ISSENSITIVE                                                *terraform-function-issensitive*

https://developer.hashicorp.com/terraform/language/functions/issensitive

---
page_title: issensitive - Functions - Configuration Language
description: The issensitive function true if the value passed is marked as sensitive
---

# `issensitive` Function

-> **Note:** This function is only available in Terraform v1.8 and later.

`issensitive` takes any value and returns true if Terraform
treats it as sensitive, with the same meaning and behavior as for
[sensitive input variables](/terraform/language/values/variables#suppressing-values-in-cli-output).

If a value not marked as sensitive is passed the function returns false.

See [`sensitive`](/terraform/language/functions/sensitive), [`nonsensitive`](/terraform/language/functions/nonsensitive), and [sensitive input variables](/terraform/language/values/variables#suppressing-values-in-cli-output) for more information on sensitive values.

## Examples

```
> issensitive(sensitive("secret"))
true
> issensitive("hello")
false
> issensitive(var.my-var-with-sensitive-set-to-true)
true
```

JOIN                                                       *terraform-function-join*

https://developer.hashicorp.com/terraform/language/functions/join

---
page_title: join - Functions - Configuration Language
description: |-
  The join function produces a string by concatenating the elements of a list
  with a given delimiter.
---

# `join` Function

`join` produces a string by concatenating all of the elements of the specified
list of strings with the specified separator.

```hcl
join(separator, list)
```

## Examples

```
> join("-", ["foo", "bar", "baz"])
"foo-bar-baz"
> join(", ", ["foo", "bar", "baz"])
foo, bar, baz
> join(", ", ["foo"])
foo
```

## Related Functions

* [`split`](/terraform/language/functions/split) performs the opposite operation: producing a list
  by separating a single string using a given delimiter.

JSONDECODE                                                 *terraform-function-jsondecode*

https://developer.hashicorp.com/terraform/language/functions/jsondecode

---
page_title: jsondecode - Functions - Configuration Language
description: |-
  The jsondecode function decodes a JSON string into a representation of its
  value.
---

# `jsondecode` Function

`jsondecode` interprets a given string as JSON, returning a representation
of the result of decoding that string.

The JSON encoding is defined in [RFC 7159](https://tools.ietf.org/html/rfc7159).

This function maps JSON values to
[Terraform language values](/terraform/language/expressions/types)
in the following way:

| JSON type | Terraform type                                               |
| --------- | ------------------------------------------------------------ |
| String    | `string`                                                     |
| Number    | `number`                                                     |
| Boolean   | `bool`                                                       |
| Object    | `object(...)` with attribute types determined per this table |
| Array     | `tuple(...)` with element types determined per this table    |
| Null      | The Terraform language `null` value                          |

The Terraform language automatic type conversion rules mean that you don't
usually need to worry about exactly what type is produced for a given value,
and can just use the result in an intuitive way.

## Examples

```
> jsondecode("{\"hello\": \"world\"}")
{
  "hello" = "world"
}
> jsondecode("true")
true
```

## Related Functions

* [`jsonencode`](/terraform/language/functions/jsonencode) performs the opposite operation, _encoding_
  a value as JSON.

JSONENCODE                                                 *terraform-function-jsonencode*

https://developer.hashicorp.com/terraform/language/functions/jsonencode

---
page_title: jsonencode - Functions - Configuration Language
description: The jsonencode function encodes a given value as a JSON string.
---

# `jsonencode` Function

`jsonencode` encodes a given value to a string using JSON syntax.

The JSON encoding is defined in [RFC 7159](https://tools.ietf.org/html/rfc7159).

This function maps
[Terraform language values](/terraform/language/expressions/types)
to JSON values in the following way:

| Terraform type | JSON type |
| -------------- | --------- |
| `string`       | String    |
| `number`       | Number    |
| `bool`         | Bool      |
| `list(...)`    | Array     |
| `set(...)`     | Array     |
| `tuple(...)`   | Array     |
| `map(...)`     | Object    |
| `object(...)`  | Object    |
| Null value     | `null`    |

Since the JSON format cannot fully represent all of the Terraform language
types, passing the `jsonencode` result to `jsondecode` will not produce an
identical value, but the automatic type conversion rules mean that this is
rarely a problem in practice.

When encoding strings, this function escapes some characters using
Unicode escape sequences: replacing `<`, `>`, `&`, `U+2028`, and `U+2029` with
`\u003c`, `\u003e`, `\u0026`, `\u2028`, and `\u2029`. This is to preserve
compatibility with Terraform 0.11 behavior.

The `jsonencode` command outputs a minified representation of the input.

## Examples

```
> jsonencode({"hello"="world"})
{"hello":"world"}
```

## Related Functions

* [`jsondecode`](/terraform/language/functions/jsondecode) performs the opposite operation, _decoding_
  a JSON string to obtain its represented value.

KEYS                                                       *terraform-function-keys*

https://developer.hashicorp.com/terraform/language/functions/keys

---
page_title: keys - Functions - Configuration Language
description: The keys function returns a list of the keys in a given map.
---

# `keys` Function

`keys` takes a map and returns a list containing the keys from that map.

The keys are returned in lexicographical order, ensuring that the result will
be identical as long as the keys in the map don't change.

## Examples

```
> keys({a=1, c=2, d=3})
[
  "a",
  "c",
  "d",
]
```

## Related Functions

* [`values`](/terraform/language/functions/values) returns a list of the _values_ from a map.

LENGTH                                                     *terraform-function-length*

https://developer.hashicorp.com/terraform/language/functions/length

---
page_title: length - Functions - Configuration Language
description: The length function determines the length of a collection or string.
---

# `length` Function

`length` determines the length of a given list, map, or string.

If given a list or map, the result is the number of elements in that collection.
If given a string, the result is the number of characters in the string.

## Examples

```
> length([])
0
> length(["a", "b"])
2
> length({"a" = "b"})
1
> length("hello")
5
```

When given a string, the result is the number of characters, rather than the
number of bytes or Unicode sequences that form them:

```
> length("👾🕹️")
2
```

A "character" is a _grapheme cluster_, as defined by
[Unicode Standard Annex #29](http://unicode.org/reports/tr29/). Note that
remote APIs may have a different definition of "character" for the purpose of
length limits on string arguments; a Terraform provider is responsible for
translating Terraform's string representation into that used by its respective
remote system and applying any additional validation rules to it.

LIST                                                       *terraform-function-list*

https://developer.hashicorp.com/terraform/language/functions/list

---
page_title: list - Functions - Configuration Language
description: The list function constructs a list from some given elements.
---

# `list` Function

The `list` function is no longer available. Prior to Terraform v0.12 it was
the only available syntax for writing a literal list inside an expression,
but Terraform v0.12 introduced a new first-class syntax.

To update an expression like `list(a, b, c)`, write the following instead:

```hcl
tolist([a, b, c])
```

The `[ ... ]` brackets construct a tuple value, and then the `tolist` function
then converts it to a list. For more information on the value types in the
Terraform language, see [Type Constraints](/terraform/language/expressions/types).

## Related Functions

* [`concat`](/terraform/language/functions/concat) produces a new list by concatenating together the
  elements from other lists.
* [`tolist`](/terraform/language/functions/tolist) converts a set or tuple value to a list.

LOG                                                        *terraform-function-log*

https://developer.hashicorp.com/terraform/language/functions/log

---
page_title: log - Functions - Configuration Language
description: The log function returns the logarithm of a given number in a given base.
---

# `log` Function

`log` returns the logarithm of a given number in a given base.

```hcl
log(number, base)
```

## Examples

```
> log(50, 10)
1.6989700043360185
> log(16, 2)
4
```

`log` and `ceil` can be used together to find the minimum number of binary
digits required to represent a given number of distinct values:

```
> ceil(log(15, 2))
4
> ceil(log(16, 2))
4
> ceil(log(17, 2))
5
```

LOOKUP                                                     *terraform-function-lookup*

https://developer.hashicorp.com/terraform/language/functions/lookup

---
page_title: lookup - Functions - Configuration Language
description: The lookup function retrieves an element value from a map given its key.
---

# `lookup` Function

`lookup` retrieves the value of a single element from a map, given its key.
If the given key does not exist, the given default value is returned instead.

```hcl
lookup(map, key, default)
```

-> For historical reasons, the `default` parameter is actually optional. However,
omitting `default` is deprecated since v0.7 because that would then be
equivalent to the native index syntax, `map[key]`.

## Examples

```
> lookup({a="ay", b="bee"}, "a", "what?")
ay
> lookup({a="ay", b="bee"}, "c", "what?")
what?
```

## Related Functions

* [`element`](/terraform/language/functions/element) retrieves a value from a _list_ given its _index_.

LOWER                                                      *terraform-function-lower*

https://developer.hashicorp.com/terraform/language/functions/lower

---
page_title: lower - Functions - Configuration Language
description: >-
  The lower function converts all cased letters in the given string to
  lowercase.
---

# `lower` Function

`lower` converts all cased letters in the given string to lowercase.

## Examples

```
> lower("HELLO")
hello
> lower("ΓΕΙΑ ΣΟΥ")
"γεια σου"
```

This function uses Unicode's definition of letters and of upper- and lowercase.

## Related Functions

* [`upper`](/terraform/language/functions/upper) converts letters in a string to _uppercase_.
* [`title`](/terraform/language/functions/title) converts the first letter of each word in a string to uppercase.

MAP                                                        *terraform-function-map*

https://developer.hashicorp.com/terraform/language/functions/map

---
page_title: map - Functions - Configuration Language
description: The map function constructs a map from some given elements.
---

# `map` Function

The `map` function is no longer available. Prior to Terraform v0.12 it was
the only available syntax for writing a literal map inside an expression,
but Terraform v0.12 introduced a new first-class syntax.

To update an expression like `map("a", "b", "c", "d")`, write the following instead:

```hcl
tomap({
  a = "b"
  c = "d"
})
```

The `{ ... }` braces construct an object value, and then the `tomap` function
then converts it to a map. For more information on the value types in the
Terraform language, see [Type Constraints](/terraform/language/expressions/types).

## Related Functions

* [`tomap`](/terraform/language/functions/tomap) converts an object value to a map.
* [`zipmap`](/terraform/language/functions/zipmap) constructs a map dynamically, by taking keys from
  one list and values from another list.

MATCHKEYS                                                  *terraform-function-matchkeys*

https://developer.hashicorp.com/terraform/language/functions/matchkeys

---
page_title: matchkeys - Functions - Configuration Language
description: |-
  The matchkeys function takes a subset of elements from one list by matching
  corresponding indexes in another list.
---

# `matchkeys` Function

`matchkeys` constructs a new list by taking a subset of elements from one
list whose indexes match the corresponding indexes of values in another
list.

```hcl
matchkeys(valueslist, keyslist, searchset)
```

`matchkeys` identifies the indexes in `keyslist` that are equal to elements of
`searchset`, and then constructs a new list by taking those same indexes from
`valueslist`. Both `valueslist` and `keyslist` must be the same length.

The ordering of the values in `valueslist` is preserved in the result.

## Examples

```
> matchkeys(["i-123", "i-abc", "i-def"], ["us-west", "us-east", "us-east"], ["us-east"])
[
  "i-abc",
  "i-def",
]
```

If the result ordering is not significant, you can achieve a similar result
using a `for` expression with a map:

```
> [for i, z in {"i-123"="us-west","i-abc"="us-east","i-def"="us-east"}: i if z == "us-east"]
[
  "i-def",
  "i-abc",
]
```

If the keys and values of interest are attributes of objects in a list of
objects then you can also achieve a similar result using a `for` expression
with that list:

```
> [for x in [{id="i-123",zone="us-west"},{id="i-abc",zone="us-east"}]: x.id if x.zone == "us-east"]
[
  "i-abc",
]
```

For example, the previous form can be used with the list of resource instances
produced by a `resource` block with the `count` meta-attribute set, to filter
the instances by matching one of the resource attributes:

```
> [for x in aws_instance.example: x.id if x.availability_zone == "us-east-1a"]
[
  "i-abc123",
  "i-def456",
]
```

Since the signature of `matchkeys` is complicated and not immediately clear to
the reader when used in configuration, prefer to use `for` expressions where
possible to maximize readability.

MAX                                                        *terraform-function-max*

https://developer.hashicorp.com/terraform/language/functions/max

---
page_title: max - Functions - Configuration Language
description: The max function takes one or more numbers and returns the greatest number.
---

# `max` Function

`max` takes one or more numbers and returns the greatest number from the set.

## Examples

```
> max(12, 54, 3)
54
```

If the numbers are in a list or set value, use `...` to expand the collection
to individual arguments:

```
> max([12, 54, 3]...)
54
```

## Related Functions

* [`min`](/terraform/language/functions/min), which returns the _smallest_ number from a set.

MD5                                                        *terraform-function-md5*

https://developer.hashicorp.com/terraform/language/functions/md5

---
page_title: md5 - Functions - Configuration Language
description: |-
  The md5 function computes the MD5 hash of a given string and encodes it
  with hexadecimal digits.
---

# `md5` Function

`md5` computes the MD5 hash of a given string and encodes it with
hexadecimal digits.

The given string is first encoded as UTF-8 and then the MD5 algorithm is applied
as defined in [RFC 1321](https://tools.ietf.org/html/rfc1321). The raw hash is
then encoded to lowercase hexadecimal digits before returning.

Collision attacks have been successfully performed against this hashing
function. Before using this function for anything security-sensitive, refer to
[RFC 6151](https://tools.ietf.org/html/rfc6151) for updated security
considerations applying to the MD5 algorithm.

## Examples

```
> md5("hello world")
5eb63bbbe01eeed093cb22bb8f5acdc3
```

## Related Functions

* [`filemd5`](/terraform/language/functions/filemd5) calculates the same hash from
  the contents of a file rather than from a string value.

MERGE                                                      *terraform-function-merge*

https://developer.hashicorp.com/terraform/language/functions/merge

---
page_title: merge - Functions - Configuration Language
description: |-
  The merge function takes an arbitrary number maps or objects, and returns a
  single map or object that contains a merged set of elements from all
  arguments.
---

# `merge` Function

`merge` takes an arbitrary number of maps or objects, and returns a single map
or object that contains a merged set of elements from all arguments.

If more than one given map or object defines the same key or attribute, then
the one that is later in the argument sequence takes precedence. If the
argument types do not match, the resulting type will be an object matching the
type structure of the attributes after the merging rules have been applied.

## Examples

```
> merge({a="b", c="d"}, {e="f", c="z"})
{
  "a" = "b"
  "c" = "z"
  "e" = "f"
}
```

```
> merge({a="b"}, {a=[1,2], c="z"}, {d=3})
{
  "a" = [
    1,
    2,
  ]
  "c" = "z"
  "d" = 3
}
```

The following example uses the expansion symbol (...) to transform the value into separate arguments. Refer to [Expanding Function Argument](/terraform/language/expressions/function-calls#expanding-function-arguments) for details.

```
> merge([{a="b", c="d"}, {}, {e="f", c="z"}]...)
{
  "a" = "b"
  "c" = "z"
  "e" = "f"
}
```

MIN                                                        *terraform-function-min*

https://developer.hashicorp.com/terraform/language/functions/min

---
page_title: min - Functions - Configuration Language
description: The min function takes one or more numbers and returns the smallest number.
---

# `min` Function

`min` takes one or more numbers and returns the smallest number from the set.

## Examples

```
> min(12, 54, 3)
3
```

If the numbers are in a list or set value, use `...` to expand the collection
to individual arguments:

```
> min([12, 54, 3]...)
3
```

## Related Functions

* [`max`](/terraform/language/functions/max), which returns the _greatest_ number from a set.

NONSENSITIVE                                               *terraform-function-nonsensitive*

https://developer.hashicorp.com/terraform/language/functions/nonsensitive

---
page_title: nonsensitive - Functions - Configuration Language
description: >-
  The nonsensitive function removes the sensitive marking from a value that
  Terraform considers to be sensitive.
---

# `nonsensitive` Function

-> **Note:** This function is only available in Terraform v0.15 and later.

`nonsensitive` takes a sensitive value and returns a copy of that value with
the sensitive marking removed, thereby exposing the sensitive value.

~> **Warning:** Using this function indiscriminately will cause values that
Terraform would normally have considered as sensitive to be treated as normal
values and shown clearly in Terraform's output. Use this function only when
you've derived a new value from a sensitive value in a way that eliminates the
sensitive portions of the value.

Normally Terraform tracks when you use expressions to derive a new value from
a value that is marked as sensitive, so that the result can also be marked
as sensitive.

However, you may wish to write expressions that derive non-sensitive results
from sensitive values. For example, if you know based on details of your
particular system and its threat model that a SHA256 hash of a particular
sensitive value is safe to include clearly in Terraform output, you could use
the `nonsensitive` function to indicate that, overriding Terraform's normal
conservative behavior:

```hcl
output "sensitive_example_hash" {
  value = nonsensitive(sha256(var.sensitive_example))
}
```

Another example might be if the original value is only partially sensitive and
you've written expressions to separate the sensitive and non-sensitive parts:

```hcl
variable "mixed_content_json" {
  description = "A JSON string containing a mixture of sensitive and non-sensitive values."
  type        = string
  sensitive   = true
}

locals {
  # mixed_content is derived from var.mixed_content_json, so it
  # is also considered to be sensitive.
  mixed_content = jsondecode(var.mixed_content_json)

  # password_from_json is derived from mixed_content, so it's
  # also considered to be sensitive.
  password_from_json = local.mixed_content["password"]

  # username_from_json would normally be considered to be
  # sensitive too, but system-specific knowledge tells us
  # that the username is a non-sensitive fragment of the
  # original document, and so we can override Terraform's
  # determination.
  username_from_json = nonsensitive(local.mixed_content["username"])
}
```

When you use this function, it's your responsibility to ensure that the
expression passed as its argument will remove all sensitive content from
the sensitive value it depends on. By passing a value to `nonsensitive` you are
declaring to Terraform that you have done all that is necessary to ensure that
the resulting value has no sensitive content, even though it was derived
from sensitive content. If a sensitive value appears in Terraform's output
due to an inappropriate call to `nonsensitive` in your module, that's a bug in
your module and not a bug in Terraform itself.
**Use this function sparingly and only with due care.**

`nonsensitive` will make no changes to values that aren't marked as sensitive, even though such a call may be redundant and potentially confusing.
Use `nonsensitive` only after careful consideration and with definite intent.

Consider including a comment adjacent to your call to explain to future
maintainers what makes the usage safe and thus what invariants they must take
care to preserve under future modifications.

## Examples

The following examples are from `terraform console` when running in the
context of the example above with `variable "mixed_content_json"` and
the local value `mixed_content`, with a valid JSON string assigned to
`var.mixed_content_json`.

```
> var.mixed_content_json
(sensitive value)
> local.mixed_content
(sensitive value)
> local.mixed_content["password"]
(sensitive value)
> nonsensitive(local.mixed_content["username"])
"zqb"
> nonsensitive("clear")

Error: Invalid function argument

Invalid value for "value" parameter: the given value is not sensitive, so this
call is redundant.
```

Note though that it's always your responsibility to use `nonsensitive` only
when it's safe to do so. If you use `nonsensitive` with content that
_ought to be_ considered sensitive then that content will be disclosed:

```
> nonsensitive(var.mixed_content_json)
<<EOT
{
  "username": "zqb",
  "password": "p4ssw0rd"
}
EOT
> nonsensitive(local.mixed_content)
{
  "password" = "p4ssw0rd"
  "username" = "zqb"
}
> nonsensitive(local.mixed_content["password"])
"p4ssw0rd"
```

ONE                                                        *terraform-function-one*

https://developer.hashicorp.com/terraform/language/functions/one

---
page_title: one - Functions - Configuration Language
description: |-
  The 'one' function transforms a list with either zero or one elements into
  either a null value or the value of the first element.
---

# `one` Function

-> **Note:** This function is available only in Terraform v0.15 and later.

`one` takes a list, set, or tuple value with either zero or one elements.
If the collection is empty, `one` returns `null`. Otherwise, `one` returns
the first element. If there are two or more elements then `one` will return
an error.

This is a specialized function intended for the common situation where a
conditional item is represented as either a zero- or one-element list, where
a module author wishes to return a single value that might be null instead.

For example:

```hcl
variable "include_ec2_instance" {
  type    = bool
  default = true
}

resource "aws_instance" "example" {
  count = var.include_ec2_instance ? 1 : 0

  # (other resource arguments...)
}

output "instance_ip_address" {
  value = one(aws_instance.example[*].private_ip)
}
```

Because the `aws_instance` resource above has the `count` argument set to a
conditional that returns either zero or one, the value of
`aws_instance.example` is a list of either zero or one elements. The
`instance_ip_address` output value uses the `one` function as a concise way
to return either the private IP address of a single instance, or `null` if
no instances were created.

## Relationship to the "Splat" Operator

The Terraform language has a built-in operator `[*]`, known as
[the _splat_ operator](/terraform/language/expressions/splat), and one of its functions
is to translate a primitive value that might be null into a list of either
zero or one elements:

```hcl
variable "ec2_instance_type" {
  description = "The type of instance to create. If set to null, no instance will be created."

  type    = string
  default = null
}

resource "aws_instance" "example" {
  count = length(var.ec2_instance_type[*])

  instance_type = var.ec2_instance_type
  # (other resource arguments...)
}

output "instance_ip_address" {
  value = one(aws_instance.example[*].private_ip)
}
```

In this case we can see that the `one` function is, in a sense, the opposite
of applying `[*]` to a primitive-typed value. Splat can convert a possibly-null
value into a zero-or-one list, and `one` can reverse that to return to a
primitive value that might be null.

## Examples

```
> one([])
null
> one(["hello"])
"hello"
> one(["hello", "goodbye"])

Error: Invalid function argument

Invalid value for "list" parameter: must be a list, set, or tuple value with
either zero or one elements.
```

### Using `one` with sets

The `one` function can be particularly helpful in situations where you have a
set that you know has only zero or one elements. Set values don't support
indexing, so it's not valid to write `var.set[0]` to extract the "first"
element of a set, but if you know that there's only one item then `one` can
isolate and return that single item:

```
> one(toset([]))
null
> one(toset(["hello"]))
"hello"
```

Don't use `one` with sets that might have more than one element. This function
will fail in that case:

```
> one(toset(["hello","goodbye"]))

Error: Invalid function argument

Invalid value for "list" parameter: must be a list, set, or tuple value with
either zero or one elements.
```

PARSEINT                                                   *terraform-function-parseint*

https://developer.hashicorp.com/terraform/language/functions/parseint

---
page_title: parseint - Functions - Configuration Language
description: >-
  The parseint function parses the given string as a representation of an
  integer.
---

# `parseint` Function

`parseint` parses the given string as a representation of an integer in
the specified base and returns the resulting number. The base must be between 2
and 62 inclusive.

All bases use the arabic numerals 0 through 9 first. Bases between 11 and 36
inclusive use case-insensitive latin letters to represent higher unit values.
Bases 37 and higher use lowercase latin letters and then uppercase latin
letters.

If the given string contains any non-digit characters or digit characters that
are too large for the given base then `parseint` will produce an error.

## Examples

```
> parseint("100", 10)
100

> parseint("FF", 16)
255

> parseint("-10", 16)
-16

> parseint("1011111011101111", 2)
48879

> parseint("aA", 62)
656

> parseint("12", 2)

Error: Invalid function argument

Invalid value for "number" parameter: cannot parse "12" as a base 2 integer.
```

## Related Functions

* [`format`](/terraform/language/functions/format) can format numbers and other values into strings,
  with optional zero padding, alignment, etc.

PATHEXPAND                                                 *terraform-function-pathexpand*

https://developer.hashicorp.com/terraform/language/functions/pathexpand

---
page_title: pathexpand - Functions - Configuration Language
description: |-
  The pathexpand function expands a leading ~ character to the current user's
  home directory.
---

# `pathexpand` Function

`pathexpand` takes a filesystem path that might begin with a `~` segment,
and if so it replaces that segment with the current user's home directory
path.

This function works only with the path string and does not access the
filesystem itself. It is therefore unable to take into account filesystem
features such as symlinks.

If the leading segment in the path is not `~` then the given path is returned
unmodified.

Using this function in resource arguments will cause spurious diffs if the
same configuration is run by multiple users with different home directory
paths, or used on different host operating systems. We recommend using this
function only for transient values, such as in `connection` and `provisioner`
blocks to locate SSH keys, etc.

The rules for determining the "home directory" for the current user vary
depending on host operating system.

**For Unix systems**, the following sources are consulted, in order of preference:

* The `HOME` environment variable.
* The result of running `getent passwd` followed by the Terraform process uid.
* The result of running `cd && pwd` in `sh`.

**For Windows systems**, there is not really the concept of a home directory
in the same sense as on Unix, but the following sources are consulted in
order of preference:

* The `HOME` environment variable.
* The `HOMEDRIVE` and `HOMEPATH` environment variables, if both are set.
* The `USERPROFILE` environment variable.

The exact rules employed for each operating system may change in future
releases of Terraform.

## Examples

```
> pathexpand("~/.ssh/id_rsa")
/home/steve/.ssh/id_rsa
> pathexpand("/etc/resolv.conf")
/etc/resolv.conf
```

PLANTIMESTAMP                                              *terraform-function-plantimestamp*

https://developer.hashicorp.com/terraform/language/functions/plantimestamp

---
page_title: plantimestamp - Functions - Configuration Language
description: |-
  The plantimestamp functions a string representation of the date and time
  during the plan.
---

# `plantimestamp` Function

-> **Note:** This function is only available in Terraform v1.5 and later.

`plantimestamp` returns a UTC timestamp string in [RFC 3339](https://tools.ietf.org/html/rfc3339) format.

In the Terraform language, timestamps are conventionally represented as
strings using [RFC 3339](https://tools.ietf.org/html/rfc3339)
"Date and Time format" syntax, and so `plantimestamp` returns a string
in this format.

The result of this function will change for every plan operation. It is intended
for use within [Custom Conditions](/terraform/language/expressions/custom-conditions)
as a way to validate time sensitive resources such as TLS certificates.

There are circumstances, such as during a Terraform [Refresh-only](/terraform/cli/commands/plan#planning-modes) plan, where
the value for this function will be recomputed but not propagated to resources
defined within the configuration. As such, it is recommended that this function
only be used to compare against timestamps exported by providers and not against
timestamps generated in the configuration.

The `plantimestamp` function is not available within the Terraform console.

## Examples

```
> plantimestamp()
2018-05-13T07:44:12Z
```

```terraform
check "terraform_io_certificate" {
  data "tls_certificate" "terraform_io" {
    url = "https://www.terraform.io/"
  }

  assert {
    condition = timecmp(plantimestamp(), data.tls_certificate.terraform_io.certificates[0].not_after) < 0
    error_message = "terraform.io certificate has expired"
  }
}
```

## Related Functions

* [`timestamp`](/terraform/language/functions/timestamp) returns the current timestamp when it is evaluated
during the apply step.
POW                                                        *terraform-function-pow*

https://developer.hashicorp.com/terraform/language/functions/pow

---
page_title: pow - Functions - Configuration Language
description: The pow function raises a number to a power.
---

# `pow` Function

`pow` calculates an exponent, by raising its first argument to the power of the second argument.

## Examples

```
> pow(3, 2)
9
> pow(4, 0)
1
```

RANGE                                                      *terraform-function-range*

https://developer.hashicorp.com/terraform/language/functions/range

---
page_title: range - Functions - Configuration Language
description: The range function generates sequences of numbers.
---

# `range` Function

`range` generates a list of numbers using a start value, a limit value,
and a step value.

```hcl
range(max)
range(start, limit)
range(start, limit, step)
```

The `start` and `step` arguments can be omitted, in which case `start` defaults
to zero and `step` defaults to either one or negative one depending on whether
`limit` is greater than or less than `start`.

The resulting list is created by starting with the given `start` value and
repeatedly adding `step` to it until the result is equal to or beyond `limit`.

The interpretation of `limit` depends on the direction of `step`: for a positive
step, the sequence is complete when the next number is greater than or equal
to `limit`. For a negative step, it's complete when less than or equal.

The sequence-building algorithm follows the following pseudocode:

```
let num = start
while num < limit: (or, for negative step, num > limit)
  append num to the sequence
  num = num + step
return the sequence
```

Because the sequence is created as a physical list in memory, Terraform imposes
an artificial limit of 1024 numbers in the resulting sequence in order to avoid
unbounded memory usage if, for example, a very large value were accidentally
passed as the limit or a very small value as the step. If the algorithm above
would append the 1025th number to the sequence, the function immediately exits
with an error.

We recommend iterating over existing collections where possible, rather than
creating ranges. However, creating small numerical sequences can sometimes
be useful when combined with other collections in collection-manipulation
functions or `for` expressions.

## Examples

```
> range(3)
[
  0,
  1,
  2,
]

> range(1, 4)
[
  1,
  2,
  3,
]

> range(1, 8, 2)
[
  1,
  3,
  5,
  7,
]

> range(1, 4, 0.5)
[
  1,
  1.5,
  2,
  2.5,
  3,
  3.5,
]

> range(4, 1)
[
  4,
  3,
  2,
]

> range(10, 5, -2)
[
  10,
  8,
  6,
]
```

The `range` function is primarily useful when working with other collections
to produce a certain number of instances of something. For example:

```hcl
variable "name_counts" {
  type    = map(number)
  default = {
    "foo" = 2
    "bar" = 4
  }
}

locals {
  expanded_names = {
    for name, count in var.name_counts : name => [
      for i in range(count) : format("%s%02d", name, i)
    ]
  }
}

output "expanded_names" {
  value = local.expanded_names
}

# Produces the following expanded_names value when run with the default
# "name_counts":
#
# {
#   "bar" = [
#     "bar00",
#     "bar01",
#     "bar02",
#     "bar03",
#   ]
#   "foo" = [
#     "foo00",
#     "foo01",
#   ]
# }
```

REGEXALL                                                   *terraform-function-regexall*

https://developer.hashicorp.com/terraform/language/functions/regexall

---
page_title: regexall - Functions - Configuration Language
description: >-
  The regex function applies a regular expression to a string and returns a list
  of all matches.
---

# `regexall` Function

`regexall` applies a
[regular expression](https://en.wikipedia.org/wiki/Regular_expression)
to a string and returns a list of all matches.

```hcl
regexall(pattern, string)
```

`regexall` is a variant of [`regex`](/terraform/language/functions/regex) and uses the same pattern
syntax. For any given input to `regex`, `regexall` returns a list of whatever
type `regex` would've returned, with one element per match. That is:

- If the pattern has no capture groups at all, the result is a list of
  strings.
- If the pattern has one or more _unnamed_ capture groups, the result is a
  list of lists.
- If the pattern has one or more _named_ capture groups, the result is a
  list of maps.

`regexall` can also be used to test whether a particular string matches a
given pattern, by testing whether the length of the resulting list of matches
is greater than zero.

## Examples

```
> regexall("[a-z]+", "1234abcd5678efgh9")
[
  "abcd",
  "efgh",
]

> length(regexall("[a-z]+", "1234abcd5678efgh9"))
2

> length(regexall("[a-z]+", "123456789")) > 0
false
```

## Related Functions

- [`regex`](/terraform/language/functions/regex) searches for a single match of a given pattern, and
  returns an error if no match is found.

If Terraform already has a more specialized function to parse the syntax you
are trying to match, prefer to use that function instead. Regular expressions
can be hard to read and can obscure your intent, making a configuration harder
to read and understand.

REGEX                                                      *terraform-function-regex*

https://developer.hashicorp.com/terraform/language/functions/regex

---
page_title: regex - Functions - Configuration Language
description: |-
  The regex function applies a regular expression to a string and returns the
  matching substrings.
---

# `regex` Function

`regex` applies a
[regular expression](https://en.wikipedia.org/wiki/Regular_expression)
to a string and returns the matching substrings.

```hcl
regex(pattern, string)
```

The return type of `regex` depends on the capture groups, if any, in the
pattern:

- If the pattern has no capture groups at all, the result is a single string
  covering the substring matched by the pattern as a whole.
- If the pattern has one or more _unnamed_ capture groups, the result is a
  list of the captured substrings in the same order as the definition of
  the capture groups.
- If the pattern has one or more _named_ capture groups, the result is a
  map of the captured substrings, using the capture group names as map keys.

It's not valid to mix both named and unnamed capture groups in the same pattern.

If the given pattern does not match at all, the `regex` raises an error. To
_test_ whether a given pattern matches a string, use
[`regexall`](/terraform/language/functions/regexall) and test that the result has length greater than
zero.

The pattern is a string containing a mixture of literal characters and special
matching operators as described in the following table. Note that when giving a
regular expression pattern as a literal quoted string in the Terraform
language, the quoted string itself already uses backslash `\` as an escape
character for the string, so any backslashes intended to be recognized as part
of the pattern must be escaped as `\\`.

| Sequence               | Matches                                                                          |
| ---------------------- | -------------------------------------------------------------------------------- |
| `.`                    | Any character except newline                                                     |
| `[xyz]`                | Any character listed between the brackets (`x`, `y`, and `z` in this example)    |
| `[a-z]`                | Any character between `a` and `z`, inclusive                                     |
| `[^xyz]`               | The opposite of `[xyz]`                                                          |
| `\d`                   | ASCII digits (0 through 9, inclusive)                                            |
| `\D`                   | Anything except ASCII digits                                                     |
| `\s`                   | ASCII spaces (space, tab, newline, carriage return, form feed)                   |
| `\S`                   | Anything except ASCII spaces                                                     |
| `\w`                   | The same as `[0-9A-Za-z_]`                                                       |
| `\W`                   | Anything except the characters matched by `\w`                                   |
| `[[:alnum:]]`          | The same as `[0-9A-Za-z]`                                                        |
| `[[:alpha:]]`          | The same as `[A-Za-z]`                                                           |
| `[[:ascii:]]`          | Any ASCII character                                                              |
| `[[:blank:]]`          | ASCII tab or space                                                               |
| `[[:cntrl:]]`          | ASCII/Unicode control characters                                                 |
| `[[:digit:]]`          | The same as `[0-9]`                                                              |
| `[[:graph:]]`          | All "graphical" (printable) ASCII characters                                     |
| `[[:lower:]]`          | The same as `[a-z]`                                                              |
| `[[:print:]]`          | The same as `[[:graph:]]`                                                        |
| `[[:punct:]]`          | The same as ``[!-/:-@[-`{-~]``                                                   |
| `[[:space:]]`          | The same as `[\t\n\v\f\r ]`                                                      |
| `[[:upper:]]`          | The same as `[A-Z]`                                                              |
| `[[:word:]]`           | The same as `\w`                                                                 |
| `[[:xdigit:]]`         | The same as `[0-9A-Fa-f]`                                                        |
| `\pN`                  | Unicode character class by using single-letter class names ("N" in this example) |
| `\p{Greek}`            | Unicode character class by unicode name ("Greek" in this example)                |
| `\PN`                  | The opposite of `\pN`                                                            |
| `\P{Greek}`            | The opposite of `\p{Greek}`                                                      |
| `xy`                   | `x` followed immediately by `y`                                                  |
| `x&#124;y`             | either `x` or `y`, preferring `x`                                                |
| `x*`                   | zero or more `x`, preferring more                                                |
| `x*?`                  | zero or more `x`, preferring fewer                                               |
| `x+`                   | one or more `x`, preferring more                                                 |
| `x+?`                  | one or more `x`, preferring fewer                                                |
| `x?`                   | zero or one `x`, preferring one                                                  |
| `x??`                  | zero or one `x`, preferring zero                                                 |
| `x{n,m}`               | between `n` and `m` repetitions of `x`, preferring more                          |
| `x{n,m}?`              | between `n` and `m` repetitions of `x`, preferring fewer                         |
| `x{n,}`                | at least `n` repetitions of `x`, preferring more                                 |
| `x{n,}?`               | at least `n` repetitions of `x`, preferring fewer                                |
| `x{n}`                 | exactly `n` repetitions of `x`                                                   |
| `(x)`                  | unnamed capture group for sub-pattern `x`                                        |
| `(?P<name>x)`          | named capture group, named `name`, for sub-pattern `x`                           |
| `(?:x)`                | non-capturing sub-pattern `x`                                                    |
| `\*`                   | Literal `*` for any punctuation character `*` For example, `\.` is a literal `.` |
| `\Q...\E`              | Literal `...` for any text `...` as long as it does not include literally `\E`   |

In addition to the above matching operators that consume the characters they
match, there are some additional operators that _only_ match, but consume
no characters. These are "zero-width" matching operators:

| Sequence | Matches                                                                                          |
| -------- | ------------------------------------------------------------------------------------------------ |
| `^`      | At the beginning of the given string                                                             |
| `$`      | At the end of the given string                                                                   |
| `\A`     | At the beginning of the given string                                                             |
| `\z`     | At the end of the given string                                                                   |
| `\b`     | At an ASCII word boundary (transition between `\w` and either `\W`, `\A` or `\z`, or vice-versa) |
| `\B`     | Not at an ASCII word boundary                                                                    |

Terraform uses the
[RE2](https://github.com/google/re2/wiki/Syntax) regular expression language.
This engine does not support all of the features found in some other regular
expression engines; in particular, it does not support backreferences.

## Matching Flags

Some of the matching behaviors described above can be modified by setting
matching flags, activated using either the `(?flags)` operator (to activate
within the current sub-pattern) or the `(?flags:x)` operator (to match `x` with
the modified flags). Each flag is a single letter, and multiple flags can be
set at once by listing multiple letters in the `flags` position.
The available flags are listed in the table below:

| Flag | Meaning                                                                                                                                                     |
| ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `i`  | Case insensitive: a literal letter in the pattern matches both lowercase and uppercase versions of that letter                                              |
| `m`  | The `^` and `$` operators also match the beginning and end of lines within the string, marked by newline characters; behavior of `\A` and `\z` is unchanged |
| `s`  | The `.` operator also matches newline                                                                                                                       |
| `U`  | The meaning of presence or absense `?` after a repetition operator is inverted. For example, `x*` is interpreted like `x*?` and vice-versa.                 |

## Examples

```
> regex("[a-z]+", "53453453.345345aaabbbccc23454")
aaabbbccc

> regex("(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)", "2019-02-01")
[
  "2019",
  "02",
  "01",
]

> regex("^(?:(?P<scheme>[^:/?#]+):)?(?://(?P<authority>[^/?#]*))?", "https://terraform.io/docs/")
{
  "authority" = "terraform.io"
  "scheme" = "https"
}

> regex("[a-z]+", "53453453.34534523454")

Error: Error in function call

Call to function "regex" failed: pattern did not match any part of the given
string.
```

## Related Functions

- [`regexall`](/terraform/language/functions/regexall) searches for potentially multiple matches of a given pattern in a string.
- [`replace`](/terraform/language/functions/replace) replaces a substring of a string with another string, optionally matching using the same regular expression syntax as `regex`.

If Terraform already has a more specialized function to parse the syntax you
are trying to match, prefer to use that function instead. Regular expressions
can be hard to read and can obscure your intent, making a configuration harder
to read and understand.

REPLACE                                                    *terraform-function-replace*

https://developer.hashicorp.com/terraform/language/functions/replace

---
page_title: replace - Functions - Configuration Language
description: |-
  The replace function searches a given string for another given substring,
  and replaces all occurrences with a given replacement string.
---

# `replace` Function

`replace` searches a given string for another given substring, and replaces
each occurrence with a given replacement string.

```hcl
replace(string, substring, replacement)
```

If `substring` is wrapped in forward slashes, it is treated as a regular
expression, using the same pattern syntax as
[`regex`](/terraform/language/functions/regex). If using a regular expression for the substring
argument, the `replacement` string can incorporate captured strings from
the input by using an `$n` sequence, where `n` is the index or name of a
capture group.

## Examples

```
> replace("1 + 2 + 3", "+", "-")
1 - 2 - 3

> replace("hello world", "/w.*d/", "everybody")
hello everybody
```

## Related Functions

- [`regex`](/terraform/language/functions/regex) searches a given string for a substring matching a
  given regular expression pattern.

REVERSE                                                    *terraform-function-reverse*

https://developer.hashicorp.com/terraform/language/functions/reverse

---
page_title: reverse - Functions - Configuration Language
description: The reverse function reverses a sequence.
---

# `reverse` Function

`reverse` takes a sequence and produces a new sequence of the same length
with all of the same elements as the given sequence but in reverse order.

## Examples

```
> reverse([1, 2, 3])
[
  3,
  2,
  1,
]
```

## Related Functions

* [`strrev`](/terraform/language/functions/strrev) reverses a string.

RSADECRYPT                                                 *terraform-function-rsadecrypt*

https://developer.hashicorp.com/terraform/language/functions/rsadecrypt

---
page_title: rsadecrypt - Functions - Configuration Language
description: The rsadecrypt function decrypts an RSA-encrypted message.
---

# `rsadecrypt` Function

`rsadecrypt` decrypts an RSA-encrypted ciphertext, returning the corresponding
cleartext.

```hcl
rsadecrypt(ciphertext, privatekey)
```

`ciphertext` must be a base64-encoded representation of the ciphertext, using
the PKCS #1 v1.5 padding scheme. Terraform uses the "standard" Base64 alphabet
as defined in [RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).

`privatekey` must be a PEM-encoded RSA private key that is not itself
encrypted.

Terraform has no corresponding function for _encrypting_ a message. Use this
function to decrypt ciphertexts returned by remote services using a keypair
negotiated out-of-band.

## Examples

```
> rsadecrypt(filebase64("${path.module}/ciphertext"), file("privatekey.pem"))
Hello, world!
```

SENSITIVE                                                  *terraform-function-sensitive*

https://developer.hashicorp.com/terraform/language/functions/sensitive

---
page_title: sensitive - Functions - Configuration Language
description: The sensitive function marks a value as being sensitive.
---

# `sensitive` Function

-> **Note:** This function is only available in Terraform v0.15 and later.

`sensitive` takes any value and returns a copy of it marked so that Terraform
will treat it as sensitive, with the same meaning and behavior as for
[sensitive input variables](/terraform/language/values/variables#suppressing-values-in-cli-output).

Wherever possible we recommend marking your input variable and/or output value
declarations as sensitive directly, instead of using this function, because in
that case you can be sure that there is no way to refer to those values without
Terraform automatically considering them as sensitive.

The `sensitive` function might be useful in some less-common situations where a
sensitive value arises from a definition _within_ your module, such as if you've
loaded sensitive data from a file on disk as part of your configuration:

```hcl
locals {
  sensitive_content = sensitive(file("${path.module}/sensitive.txt"))
}
```

However, we generally don't recommend writing sensitive values directly within
your module any of the files you distribute statically as part of that module,
because they may be exposed in other ways outside of Terraform's control.

## Examples

```
> sensitive(1)
(sensitive value)
> sensitive("hello")
(sensitive value)
> sensitive([])
(sensitive value)
```

SETINTERSECTION                                            *terraform-function-setintersection*

https://developer.hashicorp.com/terraform/language/functions/setintersection

---
page_title: setintersection function reference - Functions - Configuration Language
description: |-
  The setintersection function takes multiple arrays and produces a single array
  containing only the elements that all of the given arrays have in common.
---

# `setintersection` function reference

This topic provides reference information about the `setintersection` function,
which computes the intersection of the specified sets. 

## Introduction

The `setintersection` function takes multiple sets and produces a single set
containing only the elements that all of the given sets have in common.
In other words, `setintersection` computes the intersection of the sets. 
Refer to Wikipedia's [Intersection (set
theory)](https://en.wikipedia.org/wiki/Intersection_\(set_theory\)) article
for a mathematical explanantion of set theory intersection. 

## Syntax

Use the `setintersection` function with the following syntax:

```hcl
setintersection(sets...)
```

Replace `sets...` with a comma-delimited list of sets such as `["a","b"], ["a","c","g"]`. The elements of
the different sets do not have to be the same type. 

The `setintersection` result is an unordered set.

## Example use cases

This example passes in sets of strings and returns a set with one element.

```hcl
> setintersection(["a", "b"], ["b", "c"], ["b", "d"])
[
  "b",
]
```

This example passes in number sets of different sizes and returns a set with two elements.

```hcl
> setintersection([3,3.3,4], [4,3.3,65,99], [4.0,3.3])
toset([
  3.3,
  4,
])
```

This examples pass in sets of different lengths and element types. 
The result is a set of two string elements.

```hcl
> setintersection(["bob","jane",3], ["jane",3,"ajax",10], ["3","jane",26,"nomad"])
toset([
  "3",
  "jane",
])
```

## Related Functions

* [`contains`](/terraform/language/functions/contains) tests whether a given list or set contains
  a given element value.
* [`setproduct`](/terraform/language/functions/setproduct) computes the _Cartesian product_ of multiple
  sets.
* [`setsubtract`](/terraform/language/functions/setsubtract) computes the _relative complement_ of two sets
* [`setunion`](/terraform/language/functions/setunion) computes the _union_ of
  multiple sets.

SETPRODUCT                                                 *terraform-function-setproduct*

https://developer.hashicorp.com/terraform/language/functions/setproduct

---
page_title: setproduct - Functions - Configuration Language
description: |-
  The setproduct function finds all of the possible combinations of elements
  from all of the given sets by computing the cartesian product.
---

# `setproduct` Function

The `setproduct` function finds all of the possible combinations of elements
from all of the given sets by computing the
[Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product).

```hcl
setproduct(sets...)
```

This function is particularly useful for finding the exhaustive set of all
combinations of members of multiple sets, such as per-application-per-environment
resources.

```
> setproduct(["development", "staging", "production"], ["app1", "app2"])
[
  [
    "development",
    "app1",
  ],
  [
    "development",
    "app2",
  ],
  [
    "staging",
    "app1",
  ],
  [
    "staging",
    "app2",
  ],
  [
    "production",
    "app1",
  ],
  [
    "production",
    "app2",
  ],
]
```

You must pass at least two arguments to this function.

Although defined primarily for sets, this function can also work with lists.
If all of the given arguments are lists then the result is a list, preserving
the ordering of the given lists. Otherwise the result is a set. In either case,
the result's element type is a list of values corresponding to each given
argument in turn.

## Examples

There is an example of the common usage of this function above. There are some
other situations that are less common when hand-writing but may arise in
reusable module situations.

If any of the arguments is empty then the result is always empty itself,
similar to how multiplying any number by zero gives zero:

```
> setproduct(["development", "staging", "production"], [])
[]
```

Similarly, if all of the arguments have only one element then the result has
only one element, which is the first element of each argument:

```
> setproduct(["a"], ["b"])
[
  [
    "a",
    "b",
  ],
]
```

Each argument must have a consistent type for all of its elements. If not,
Terraform will attempt to convert to the most general type, or produce an
error if such a conversion is impossible. For example, mixing both strings and
numbers results in the numbers being converted to strings so that the result
elements all have a consistent type:

```
> setproduct(["staging", "production"], ["a", 2])
[
  [
    "staging",
    "a",
  ],
  [
    "staging",
    "2",
  ],
  [
    "production",
    "a",
  ],
  [
    "production",
    "2",
  ],
]
```

## Finding combinations for `for_each`

The
[resource `for_each`](/terraform/language/meta-arguments/for_each)
and
[`dynamic` block](/terraform/language/expressions/dynamic-blocks)
language features both require a collection value that has one element for
each repetition.

Sometimes your input data comes in separate values that cannot be directly
used in a `for_each` argument, and `setproduct` can be a useful helper function
for the situation where you want to find all unique combinations of elements in
a number of different collections.

For example, consider a module that declares variables like the following:

```hcl
variable "networks" {
  type = map(object({
    base_cidr_block = string
  }))
}

variable "subnets" {
  type = map(object({
    number = number
  }))
}
```

If the goal is to create each of the defined subnets per each of the defined networks, creating the top-level networks can directly use `var.networks` because it is already in a form where the resulting instances match one-to-one with map elements:

```hcl
resource "aws_vpc" "example" {
  for_each = var.networks

  cidr_block = each.value.base_cidr_block
}
```

However, to declare all of the _subnets_ with a single `resource` block, you must first produce a collection whose elements represent all of the combinations of networks and subnets, so that each element itself represents a subnet:

```hcl
locals {
  # setproduct works with sets and lists, but the variables are both maps
  # so convert them first.
  networks = [
    for key, network in var.networks : {
      key        = key
      cidr_block = network.cidr_block
    }
  ]
  subnets = [
    for key, subnet in var.subnets : {
      key    = key
      number = subnet.number
    }
  ]

  network_subnets = [
    # in pair, element zero is a network and element one is a subnet,
    # in all unique combinations.
    for pair in setproduct(local.networks, local.subnets) : {
      network_key = pair[0].key
      subnet_key  = pair[1].key
      network_id  = aws_vpc.example[pair[0].key].id

      # The cidr_block is derived from the corresponding network. Refer to the
      # cidrsubnet function for more information on how this calculation works.
      cidr_block = cidrsubnet(pair[0].cidr_block, 4, pair[1].number)
    }
  ]
}

resource "aws_subnet" "example" {
  # local.network_subnets is a list, so project it into a map
  # where each key is unique. Combine the network and subnet keys to
  # produce a single unique key per instance.
  for_each = tomap({
    for subnet in local.network_subnets : "${subnet.network_key}.${subnet.subnet_key}" => subnet
  })

  vpc_id            = each.value.network_id
  availability_zone = each.value.subnet_key
  cidr_block        = each.value.cidr_block
}
```

The `network_subnets` list in the example above creates one subnet instance per combination of network and subnet elements in the input variables. So for this example input:

```hcl
networks = {
  a = {
    base_cidr_block = "10.1.0.0/16"
  }
  b = {
    base_cidr_block = "10.2.0.0/16"
  }
}
subnets = {
  a = {
    number = 1
  }
  b = {
    number = 2
  }
  c = {
    number = 3
  }
}
```

The `network_subnets` output would look similar to the following:

```hcl
[
  {
    "cidr_block" = "10.1.16.0/20"
    "network_id" = "vpc-0bfb00ca6173ea5aa"
    "network_key" = "a"
    "subnet_key" = "a"
  },
  {
    "cidr_block" = "10.1.32.0/20"
    "network_id" = "vpc-0bfb00ca6173ea5aa"
    "network_key" = "a"
    "subnet_key" = "b"
  },
  {
    "cidr_block" = "10.1.48.0/20"
    "network_id" = "vpc-0bfb00ca6173ea5aa"
    "network_key" = "a"
    "subnet_key" = "c"
  },
  {
    "cidr_block" = "10.2.16.0/20"
    "network_id" = "vpc-0d193e011f6211a7d"
    "network_key" = "b"
    "subnet_key" = "a"
  },
  {
    "cidr_block" = "10.2.32.0/20"
    "network_id" = "vpc-0d193e011f6211a7d"
    "network_key" = "b"
    "subnet_key" = "b"
  },
  {
    "cidr_block" = "10.2.48.0/20"
    "network_id" = "vpc-0d193e011f6211a7d"
    "network_key" = "b"
    "subnet_key" = "c"
  },
]
```

## Related Functions

- [`contains`](/terraform/language/functions/contains) tests whether a given list or set contains
  a given element value.
- [`flatten`](/terraform/language/functions/flatten) is useful for flattening hierarchical data
  into a single list, for situations where the relationships between two
  object types are defined explicitly.
- [`setintersection`](/terraform/language/functions/setintersection) computes the _intersection_ of
  multiple sets.
- [`setsubtract`](/terraform/language/functions/setsubtract) computes the _relative complement_ of two sets
- [`setunion`](/terraform/language/functions/setunion) computes the _union_ of multiple
  sets.

SETSUBTRACT                                                *terraform-function-setsubtract*

https://developer.hashicorp.com/terraform/language/functions/setsubtract

---
page_title: setsubtract - Functions - Configuration Language
description: |-
  The setsubtract function returns a new set containing the elements
  from the first set that are not present in the second set
---

# `setsubtract` Function

The `setsubtract` function returns a new set containing the elements from the first set that are not present in the second set. In other words, it computes the
[relative complement](https://en.wikipedia.org/wiki/Complement_\(set_theory\)#Relative_complement) of the second set.

```hcl
setsubtract(a, b)
```

## Examples

```
> setsubtract(["a", "b", "c"], ["a", "c"])
toset([
  "b",
])
```

### Set Difference (Symmetric Difference)

```
> setunion(setsubtract(["a", "b", "c"], ["a", "c", "d"]), setsubtract(["a", "c", "d"], ["a", "b", "c"]))
toset([
  "b",
  "d",
])
```

## Related Functions

* [`setintersection`](/terraform/language/functions/setintersection) computes the _intersection_ of multiple sets
* [`setproduct`](/terraform/language/functions/setproduct) computes the _Cartesian product_ of multiple
  sets.
* [`setunion`](/terraform/language/functions/setunion) computes the _union_ of
  multiple sets.

SETUNION                                                   *terraform-function-setunion*

https://developer.hashicorp.com/terraform/language/functions/setunion

---
page_title: setunion - Functions - Configuration Language
description: |-
  The setunion function takes multiple sets and produces a single set
  containing the elements from all of the given sets.
---

# `setunion` Function

The `setunion` function takes multiple sets and produces a single set
containing the elements from all of the given sets. In other words, it
computes the [union](https://en.wikipedia.org/wiki/Union_\(set_theory\)) of
the sets.

```hcl
setunion(sets...)
```

## Examples

```
> setunion(["a", "b"], ["b", "c"], ["d"])
[
  "d",
  "b",
  "c",
  "a",
]
```

The given arguments are converted to sets, so the result is also a set and
the ordering of the given elements is not preserved.

## Related Functions

* [`contains`](/terraform/language/functions/contains) tests whether a given list or set contains
  a given element value.
* [`setintersection`](/terraform/language/functions/setintersection) computes the _intersection_ of
  multiple sets.
* [`setproduct`](/terraform/language/functions/setproduct) computes the _Cartesian product_ of multiple
  sets.
* [`setsubtract`](/terraform/language/functions/setsubtract) computes the _relative complement_ of two sets

SHA1                                                       *terraform-function-sha1*

https://developer.hashicorp.com/terraform/language/functions/sha1

---
page_title: sha1 - Functions - Configuration Language
description: |-
  The sha1 function computes the SHA1 hash of a given string and encodes it
  with hexadecimal digits.
---

# `sha1` Function

`sha1` computes the SHA1 hash of a given string and encodes it with
hexadecimal digits.

The given string is first encoded as UTF-8 and then the SHA1 algorithm is applied
as defined in [RFC 3174](https://tools.ietf.org/html/rfc3174). The raw hash is
then encoded to lowercase hexadecimal digits before returning.

Collision attacks have been successfully performed against this hashing
function. Before using this function for anything security-sensitive, review
relevant literature to understand the security implications.

## Examples

```
> sha1("hello world")
2aae6c35c94fcfb415dbe95f408b9ce91ee846ed
```

## Related Functions

* [`filesha1`](/terraform/language/functions/filesha1) calculates the same hash from
  the contents of a file rather than from a string value.

SHA256                                                     *terraform-function-sha256*

https://developer.hashicorp.com/terraform/language/functions/sha256

---
page_title: sha256 - Functions - Configuration Language
description: |-
  The sha256 function computes the SHA256 hash of a given string and encodes it
  with hexadecimal digits.
---

# `sha256` Function

`sha256` computes the SHA256 hash of a given string and encodes it with
hexadecimal digits.

The given string is first encoded as UTF-8 and then the SHA256 algorithm is applied
as defined in [RFC 4634](https://tools.ietf.org/html/rfc4634). The raw hash is
then encoded to lowercase hexadecimal digits before returning.

## Examples

```
> sha256("hello world")
b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
```

## Related Functions

## Related Functions

* [`filesha256`](/terraform/language/functions/filesha256) calculates the same hash from
  the contents of a file rather than from a string value.
* [`base64sha256`](/terraform/language/functions/base64sha256) calculates the same hash but returns
  the result in a more-compact Base64 encoding.

SHA512                                                     *terraform-function-sha512*

https://developer.hashicorp.com/terraform/language/functions/sha512

---
page_title: sha512 - Functions - Configuration Language
description: |-
  The sha512 function computes the SHA512 hash of a given string and encodes it
  with hexadecimal digits.
---

# `sha512` Function

`sha512` computes the SHA512 hash of a given string and encodes it with
hexadecimal digits.

The given string is first encoded as UTF-8 and then the SHA512 algorithm is applied
as defined in [RFC 4634](https://tools.ietf.org/html/rfc4634). The raw hash is
then encoded to lowercase hexadecimal digits before returning.

## Examples

```
> sha512("hello world")
309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
```

## Related Functions

* [`filesha512`](/terraform/language/functions/filesha512) calculates the same hash from
  the contents of a file rather than from a string value.
* [`base64sha512`](/terraform/language/functions/base64sha512) calculates the same hash but returns
  the result in a more-compact Base64 encoding.

SIGNUM                                                     *terraform-function-signum*

https://developer.hashicorp.com/terraform/language/functions/signum

---
page_title: signum - Functions - Configuration Language
description: The signum function determines the sign of a number.
---

# `signum` Function

`signum` determines the sign of a number, returning a number between -1 and
1 to represent the sign.

## Examples

```
> signum(-13)
-1
> signum(0)
0
> signum(344)
1
```

SLICE                                                      *terraform-function-slice*

https://developer.hashicorp.com/terraform/language/functions/slice

---
page_title: slice - Functions - Configuration Language
description: The slice function extracts some consecutive elements from within a list.
---

# `slice` Function

`slice` extracts some consecutive elements from within a list.

```hcl
slice(list, startindex, endindex)
```

`startindex` is inclusive, while `endindex` is exclusive. This function returns
an error if either index is outside the bounds of valid indices for the given
list.

## Examples

```
> slice(["a", "b", "c", "d"], 1, 3)
[
  "b",
  "c",
]
```

## Related Functions

* [`substr`](/terraform/language/functions/substr) performs a similar function for characters in a
  string, although it uses a length instead of an end index.

SORT                                                       *terraform-function-sort*

https://developer.hashicorp.com/terraform/language/functions/sort

---
page_title: sort - Functions - Configuration Language
description: |-
  The sort function takes a list of strings and returns a new list with those
  strings sorted lexicographically.
---

# `sort` Function

`sort` takes a list of strings and returns a new list with those strings
sorted lexicographically.

The sort is in terms of Unicode codepoints, with higher codepoints appearing
after lower ones in the result.

## Examples

```
> sort(["e", "d", "a", "x"])
[
  "a",
  "d",
  "e",
  "x",
]
```

SPLIT                                                      *terraform-function-split*

https://developer.hashicorp.com/terraform/language/functions/split

---
page_title: split - Functions - Configuration Language
description: |-
  The split function produces a list by dividing a given string at all
  occurrences of a given separator.
---

# `split` Function

`split` produces a list by dividing a given string at all occurrences of a
given separator.

```hcl
split(separator, string)
```

## Examples

```
> split(",", "foo,bar,baz")
[
  "foo",
  "bar",
  "baz",
]
> split(",", "foo")
[
  "foo",
]
> split(",", "")
[
  "",
]
```

## Related Functions

* [`join`](/terraform/language/functions/join) performs the opposite operation: producing a string
  joining together a list of strings with a given separator.

STARTSWITH                                                 *terraform-function-startswith*

https://developer.hashicorp.com/terraform/language/functions/startswith

---
page_title: startswith - Functions - Configuration Language
description: |-
  The startswith function  takes two values: a string to check and a prefix string. It returns true if the string begins with that exact prefix.
---

# `startswith` Function

`startswith` takes two values: a string to check and a prefix string. The function returns true if the string begins with that exact prefix.

```hcl
startswith(string, prefix)
```

## Examples

```
> startswith("hello world", "hello")
true

> startswith("hello world", "world")
false
```

## Related Functions

- [`endswith`](/terraform/language/functions/endswith) takes two values: a string to check and a suffix string. The function returns true if the first string ends with that exact suffix.
STRCONTAINS                                                *terraform-function-strcontains*

https://developer.hashicorp.com/terraform/language/functions/strcontains

---
page_title: strcontains - Functions - Configuration Language
description: |-
  The strcontains function checks whether a given string can be found within another string.
---

# `strcontains` Function

`strcontains` function checks whether a substring is within another string.

```hcl
strcontains(string, substr)
```

## Examples

```
> strcontains("hello world", "wor")
true
```

```
> strcontains("hello world", "wod")
false
```
STRREV                                                     *terraform-function-strrev*

https://developer.hashicorp.com/terraform/language/functions/strrev

---
page_title: strrev - Functions - Configuration Language
description: The strrev function reverses a string.
---

# `strrev` Function

`strrev` reverses the characters in a string.
Note that the characters are treated as _Unicode characters_ (in technical terms, Unicode [grapheme cluster boundaries](https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries) are respected).

```hcl
strrev(string)
```

## Examples

```
> strrev("hello")
olleh
> strrev("a ☃")
☃ a
```

## Related Functions

* [`reverse`](/terraform/language/functions/reverse) reverses a sequence.

SUBSTR                                                     *terraform-function-substr*

https://developer.hashicorp.com/terraform/language/functions/substr

---
page_title: substr - Functions - Configuration Language
description: |-
  The substr function extracts a substring from a given string by offset and
  length.
---

# `substr` Function

`substr` extracts a substring from a given string by offset and (maximum) length.

```hcl
substr(string, offset, length)
```

## Examples

```
> substr("hello world", 1, 4)
ello
```

The offset and length are both counted in _unicode characters_ rather than
bytes:

```
> substr("🤔🤷", 0, 1)
🤔
```

The offset index may be negative, in which case it is relative to the end of
the given string.  The length may be -1, in which case the remainder of the
string after the given offset will be returned.

```
> substr("hello world", -5, -1)
world
```

If the length is greater than the length of the string, the substring
will be the length of all remaining characters.

```
> substr("hello world", 6, 10)
world
```

SUM                                                        *terraform-function-sum*

https://developer.hashicorp.com/terraform/language/functions/sum

---
page_title: sum - Functions - Configuration Language
description: |-
  The sum function takes a list or set of numbers and returns the sum of those
  numbers.
---

# `sum` Function

`sum` takes a list or set of numbers and returns the sum of those numbers.

`sum` fails when given an empty list or set.

## Examples

```
> sum([10, 13, 6, 4.5])
33.5
```

TEMPLATEFILE                                               *terraform-function-templatefile*

https://developer.hashicorp.com/terraform/language/functions/templatefile

---
page_title: templatefile - Functions - Configuration Language
description: |-
  The templatefile function reads the file at the given path and renders its
  content as a template.
---

# `templatefile` Function

`templatefile` reads the file at the given path and renders its content
as a template using a supplied set of template variables.

```hcl
templatefile(path, vars)
```

The template syntax is the same as for
[string templates](/terraform/language/expressions/strings#string-templates)
in the main Terraform language, including interpolation sequences delimited with
`${` ... `}`. This function just allows longer template sequences to be factored
out into a separate file for readability.

The "vars" argument must be an object. Within the template file, each of the
keys in the map is available as a variable for interpolation. The template may
also use any other function available in the Terraform language, except that
recursive calls to `templatefile` are not permitted. Variable names must
each start with a letter, followed by zero or more letters, digits, or
underscores.

Strings in the Terraform language are sequences of Unicode characters, so
this function will interpret the file contents as UTF-8 encoded text and
return the resulting Unicode characters. If the file contains invalid UTF-8
sequences then this function will produce an error.

This function can be used only with files that already exist on disk at the
beginning of a Terraform run. Functions do not participate in the dependency
graph, so this function cannot be used with files that are generated
dynamically during a Terraform operation.

`*.tftpl` is the recommended naming pattern to use for your template files.
Terraform will not prevent you from using other names, but following this
convention will help your editor understand the content and likely provide
better editing experience as a result.

## Examples

### Lists

Given a template file `backends.tftpl` with the following content:

```
%{ for addr in ip_addrs ~}
backend ${addr}:${port}
%{ endfor ~}
```

The `templatefile` function renders the template:

```
> templatefile("${path.module}/backends.tftpl", { port = 8080, ip_addrs = ["10.0.0.1", "10.0.0.2"] })
backend 10.0.0.1:8080
backend 10.0.0.2:8080
```

### Maps

Given a template file `config.tftpl` with the following content:

```
%{ for config_key, config_value in config }
set ${config_key} = ${config_value}
%{ endfor ~}
```

The `templatefile` function renders the template:

```
> templatefile(
               "${path.module}/config.tftpl",
               {
                 config = {
                   "x"   = "y"
                   "foo" = "bar"
                   "key" = "value"
                 }
               }
              )
set foo = bar
set key = value
set x = y
```

### Generating JSON or YAML from a template

If the string you want to generate will be in JSON or YAML syntax, it's
often tricky and tedious to write a template that will generate valid JSON or
YAML that will be interpreted correctly when using lots of individual
interpolation sequences and directives.

Instead, you can write a template that consists only of a single interpolated
call to either [`jsonencode`](/terraform/language/functions/jsonencode) or
[`yamlencode`](/terraform/language/functions/yamlencode), specifying the value to encode using
[normal Terraform expression syntax](/terraform/language/expressions)
as in the following examples:

```
${jsonencode({
  "backends": [for addr in ip_addrs : "${addr}:${port}"],
})}
```

```
${yamlencode({
  "backends": [for addr in ip_addrs : "${addr}:${port}"],
})}
```

Given the same input as the `backends.tftpl` example in the previous section,
this will produce a valid JSON or YAML representation of the given data
structure, without the need to manually handle escaping or delimiters.
In the latest examples above, the repetition based on elements of `ip_addrs` is
achieved by using a
[`for` expression](/terraform/language/expressions/for)
rather than by using
[template directives](/terraform/language/expressions/strings#directives).

```json
{"backends":["10.0.0.1:8080","10.0.0.2:8080"]}
```

If the resulting template is small, you can choose instead to write
`jsonencode` or `yamlencode` calls inline in your main configuration files, and
avoid creating separate template files at all:

```hcl
locals {
  backend_config_json = jsonencode({
    "backends": [for addr in ip_addrs : "${addr}:${port}"],
  })
}
```

For more information, see the main documentation for
[`jsonencode`](/terraform/language/functions/jsonencode) and [`yamlencode`](/terraform/language/functions/yamlencode).

## Related Functions

* [`file`](/terraform/language/functions/file) reads a file from disk and returns its literal contents
  without any template interpretation.
* [`templatestring`](/terraform/language/functions/templatestring) takes a simple reference to a string value containing the template and renders its content.

TEMPLATESTRING                                             *terraform-function-templatestring*

https://developer.hashicorp.com/terraform/language/functions/templatestring

---
page_title: templatestring - Functions - Configuration Language
description: |-
  The templatestring function takes a string from elsewhere in the module and renders its content as a template using a supplied set of template variables.
---

# `templatestring` function reference

This topic provides reference information about the `templatestring` function. The `templatestring` function renders a string defined elsewhere in the module as a template using a set of variables.

## Introduction

The primary use case for the `templatestring` function is to render templates fetched as a single string from remote locations. The function enables advanced use cases where a [string template expression](/terraform/language/expressions/strings#string-templates) is insufficient, such as when the template is available from a named object declared in the current module. Refer to [Dynamic template construction](#dynamic-template-construction) for additional information. 

To render a template from a file, use the [`templatefile` function](/terraform/language/functions/templatefile).

## Syntax

Write `templatestring` functions using the following syntax:

```hcl
templatestring(ARG1, ARG2, . . .)
```

Specify the following arguments:

- The first argument is always a reference to an object defined in the module. You cannot supply the template expression directly as the first argument.
- The second argument is an object that specifies a variable to use for rendering the template.
- You can specify additional arguments to use multiple variables for the template.  

In the following example, the function renders the string value located at `data.aws_s3_object.example.body` as the template:

```hcl
templatestring(data.aws_s3_object.example.body, {
  name = var.name
})
```

For information about the syntax you can use for the variables arguments, refer to [Strings and Templates](/terraform/language/expressions/strings).

## Example use case

The following example retrieves a template from S3 and dynamically renders it:

```hcl
data "aws_s3_object" "example" {
  bucket = "example-example"
  key    = "example.tmpl"
}

output "example" {
  value = templatestring(data.aws_s3_object.example.body, {
    name = var.name
  })
}
```

For more examples of how to use templates, refer to the documentation for [the `templatefile` function](/terraform/language/functions/templatefile#Examples).

## Dynamic template construction

You can write an expression that builds a template dynamically and then assigns it to a [local value](/terraform/language/values/locals). You can then use a reference to that local value as the first argument to the `templatestring` function.

Note that you should only dynamically construct templates in this way when no other alternative is feasible. This is because the result can be difficult to understand and maintain and is susceptible to unexpected inputs. Built-in Terraform functions may interact with the local filesystem. As a result, the inputs may produce a template that includes data from arbitrary files on the system where Terraform is running.

## Related Functions

* [`templatefile`](/terraform/language/functions/templatefile) reads a file from disk and renders its content as a template.

TERRAFORM-APPLYING                                         *terraform-function-terraform-applying*

https://developer.hashicorp.com/terraform/language/functions/terraform-applying

---
page_title: terraform.applying reference - Functions - Configuration Language
description: |-
  The terraform.applying symbol enables you to determine if Terraform is currently running an apply operation.
---

# The `terraform.applying` symbol

-> **Note**: The `terraform.applying` symbol is available in Terraform v1.10 and later.

You can use the `terraform.applying` symbol in your configuration to determine if Terraform is currently running an apply operation.

Terraform automatically sets `terraform.applying` to `true` when you run an [apply](/terraform/cli/commands/apply) operation, and `false` during any other operation. The [planning mode](/terraform/cli/commands/plan#planning-modes) you run `terraform apply` in does not affect `terraform.applying`, meaning that even in destroy mode, `terraform.applying` is still `true`.

You can use `terraform.applying` to change Terraform behavior during apply operations. In the following example, Terraform uses your read-only credentials when running a plan operation but uses your write credentials when you run an apply operation:

```hcl
locals {
  aws_read_role_arn  = "arn:aws:iam::XXXXX:role/terraform-read"
  aws_write_role_arn = "arn:aws:iam::XXXXX:role/terraform-full"

  role_arn = terraform.applying ? local.aws_write_role_arn : local.aws_read_role_arn
}

provider "aws" {
  region = "us-west-2"

  assume_role {
    role_arn     = local.role_arn
  }
}

```

The `terraform.applying` symbol is an ephemeral value and is only available during Terraform operations. Terraform does not write ephemeral values to plan or state files. Additionally, you can only reference `terraform.applying` in the following ephemeral contexts:

- In a [write-only argument](/terraform/language/resources/ephemeral/write-only)
- In [ephemeral variables](/terraform/language/values/variables#exclude-values-from-state)
- In [local values](/terraform/language/values/locals#ephemeral-values)
- In [ephemeral resources](/terraform/language/resources/ephemeral)
- In [ephemeral outputs](/terraform/language/values/outputs#ephemeral-avoid-storing-values-in-state-or-plan-files)
- Configuring providers in the `provider` block
- In [provisioner](/terraform/language/resources/provisioners/syntax) and [connection](/terraform/language/resources/provisioners/connection) blocks

TERRAFORM-DECODE_TFVARS                                    *terraform-function-terraform-decode_tfvars*

https://developer.hashicorp.com/terraform/language/functions/terraform-decode_tfvars

---
page_title: provider::terraform::decode_tfvars - Functions - Configuration Language
description: >-
  The decode_tfvars function parses a string containing syntax like that used
  in a ".tfvars" file.
---

# `provider::terraform::decode_tfvars` Function

-> **Note:** This function is supported only in Terraform v1.8 and later.

`provider::terraform::decode_tfvars` is a rarely-needed function which takes
a string containing the content of a
[`.tfvars` file](/terraform/language/values/variables#variable-definitions-tfvars-files)
and returns an object describing the raw variable values it defines.

To use this function, your module must declare a dependency on the built-in
`terraform` provider, which contains this function:

```hcl
terraform {
  required_providers {
    terraform = {
      source = "terraform.io/builtin/terraform"
    }
  }
}
```

Elsewhere in your module you can then call this function:

```hcl
provider::terraform::decode_tfvars(
  <<EOT
    example = "Hello!"
  EOT
)
```

The call above would produce an object value like the following:

```hcl
{
  example = "Hello!"
}
```

## Result Types

When interpreting a `.tfvars` file, Terraform CLI normally uses the variable
declarations from the related module to find a target type to convert the
definitions for use in the module.

`tfvarsdecode` does not have access to that type information, and so the result
always uses the most general type that a particular syntax could represent.
The supported value types for attributes of the result are:

* `string`, `number`, and `bool`
* `object` types
* `tuple` types

If you need to interpret object or tuple values as collection types, use
the type conversion functions to convert the returned values. There is no way
to represent list, set, or map values directly in the `.tfvars` format.

## Related Functions

* [`encode_tfvars`](/terraform/language/functions/terraform-encode_tfvars)
  performs the opposite operation: producing `.tfvars` content from an
  object value.

TERRAFORM-ENCODE_EXPR                                      *terraform-function-terraform-encode_expr*

https://developer.hashicorp.com/terraform/language/functions/terraform-encode_expr

---
page_title: provider::terraform::encode_expr - Functions - Configuration Language
description: >-
  The encode_expr function produces a string representation of an arbitrary value
  using Terraform expression syntax.
---

# `provider::terraform::encode_expr` Function

-> **Note:** This function is supported only in Terraform v1.8 and later.

`provider::terraform::encode_expr` is a rarely-needed function which takes
any value and produces a string containing Terraform language expression syntax
approximating that value.

To use this function, your module must declare a dependency on the built-in
`terraform` provider, which contains this function:

```hcl
terraform {
  required_providers {
    terraform = {
      source = "terraform.io/builtin/terraform"
    }
  }
}
```

The primary use for this function is in conjunction with the `hashicorp/tfe`
provider's resource type
[`tfe_variable`](https://registry.terraform.io/providers/hashicorp/tfe/latest/docs/resources/variable),
which expects variable values to be provided in Terraform expression syntax.

For example, the following concisely declares multiple input variables for
a particular HCP Terraform workspace:

```hcl
locals {
  workspace_vars = {
    example1 = "Hello"
    example2 = ["A", "B"]
  }
}

resource "tfe_variable" "test" {
  for_each = local.workspace_vars

  category     = "terraform"
  workspace_id = tfe_workspace.example.id

  key   = each.key
  value = provider::terraform::encode_expr(each.value)
  hcl   = true
}
```

When using this pattern, always set `hcl = true` in the resource declaration
to ensure that HCP Terraform will expect `value` to be given as Terraform
expression syntax.

We do not recommend using this function in any other situation.

~> **Warning:** The exact syntax used to encode certain values may change
in future versions of Terraform to follow idiomatic style. Avoid using the
results of this function in any context where such changes might be disruptive
when upgrading Terraform in future.

## Related Functions

* [`encode_tfvars`](/terraform/language/functions/terraform-encode_tfvars)
  produces expression strings for many different values at once, in `.tfvars`
  syntax.

TERRAFORM-ENCODE_TFVARS                                    *terraform-function-terraform-encode_tfvars*

https://developer.hashicorp.com/terraform/language/functions/terraform-encode_tfvars

---
page_title: provider::terraform::encode_tfvars - Functions - Configuration Language
description: >-
  The encode_tfvars function produces a string representation of an object
  using the same syntax as for ".tfvars" files used in Terraform CLI.
---

# `provider::terraform::encode_tfvars` Function

-> **Note:** This function is supported only in Terraform v1.8 and later.

`provider::terraform::encode_tfvars` is a rarely-needed function which takes
an object value and produces a string containing a description of that object
using the same syntax as Terraform CLI would expect in a
[`.tfvars` file](/terraform/language/values/variables#variable-definitions-tfvars-files).

In most cases it's better to pass data between Terraform configurations using
[Data Sources](/terraform/language/data-sources),
instead of writing generated `.tfvars` files to disk. Use this function only as
a last resort.

To use this function, your module must declare a dependency on the built-in
`terraform` provider, which contains this function:

```hcl
terraform {
  required_providers {
    terraform = {
      source = "terraform.io/builtin/terraform"
    }
  }
}
```

Elsewhere in your module you can then call this function:

```hcl
provider::terraform::encode_tfvars({
  example = "Hello!"
})
```

The call above would produce the following result:

```hcl
example = "Hello!"
```

Due to Terraform's requirements for the `.tfvars` format, all of the attributes
of the given object must be valid Terraform variable names, as would be
accepted in an
[input variable declaration](/terraform/language/values/variables#declaring-an-input-variable).

The `.tfvars` format is specific to Terraform and so we do not recommend using
it as a general serialization format.
Use [`jsonencode`](/terraform/language/functions/jsonencode) or
[`yamlencode`](/terraform/language/functions/yamlencode) instead to produce
formats that are supported by other software.

~> **Warning:** The exact syntax used to encode certain values may change
in future versions of Terraform to follow idiomatic style. Avoid using the
results of this function in any context where such changes might be disruptive
when upgrading Terraform in future.

## Related Functions

* [`decode_tfvars`](/terraform/language/functions/terraform-decode_tfvars)
  performs the opposite operation: parsing `.tfvars` content to obtain
  the variable values declared inside.
* [`encode_expr`](/terraform/language/functions/terraform-encode_expr)
  encodes a single value as a plain expression, without the `.tfvars`
  container around it.

TEXTDECODEBASE64                                           *terraform-function-textdecodebase64*

https://developer.hashicorp.com/terraform/language/functions/textdecodebase64

---
page_title: textdecodebase64 - Functions - Configuration Language
description: >-
  The textdecodebase64 function decodes a string that was previously
  Base64-encoded,

  and then interprets the result as characters in a specified character
  encoding.
---

# `textdecodebase64` Function

-> **Note:** This function is supported only in Terraform v0.14 and later.

`textdecodebase64` function decodes a string that was previously Base64-encoded,
and then interprets the result as characters in a specified character encoding.

Terraform uses the "standard" Base64 alphabet as defined in
[RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).

The `encoding_name` argument must contain one of the encoding names or aliases
recorded in
[the IANA character encoding registry](https://www.iana.org/assignments/character-sets/character-sets.xhtml).
Terraform supports only a subset of the registered encodings, and the encoding
support may vary between Terraform versions.

Terraform accepts the encoding name `UTF-8`, which will produce the same result
as [`base64decode`](/terraform/language/functions/base64decode).

## Examples

```
> textdecodebase64("SABlAGwAbABvACAAVwBvAHIAbABkAA==", "UTF-16LE")
Hello World
```

## Related Functions

* [`textencodebase64`](/terraform/language/functions/textencodebase64) performs the opposite operation,
  applying target encoding and then Base64 to a string.
* [`base64decode`](/terraform/language/functions/base64decode) is effectively a shorthand for
  `textdecodebase64` where the character encoding is fixed as `UTF-8`.

TEXTENCODEBASE64                                           *terraform-function-textencodebase64*

https://developer.hashicorp.com/terraform/language/functions/textencodebase64

---
page_title: textencodebase64 - Functions - Configuration Language
description: >-
  The textencodebase64 function encodes the unicode characters in a given string
  using a

  specified character encoding, returning the result base64 encoded.
---

# `textencodebase64` Function

-> **Note:** This function is supported only in Terraform v0.14 and later.

`textencodebase64` encodes the unicode characters in a given string using a
specified character encoding, returning the result base64 encoded because
Terraform language strings are always sequences of unicode characters.

```hcl
textencodebase64(string, encoding_name)
```

Terraform uses the "standard" Base64 alphabet as defined in
[RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).

The `encoding_name` argument must contain one of the encoding names or aliases
recorded in
[the IANA character encoding registry](https://www.iana.org/assignments/character-sets/character-sets.xhtml).
Terraform supports only a subset of the registered encodings, and the encoding
support may vary between Terraform versions. In particular Terraform supports
`UTF-16LE`, which is the native character encoding for the Windows API and
therefore sometimes expected by Windows-originated software such as PowerShell.

Terraform also accepts the encoding name `UTF-8`, which will produce the same
result as [`base64encode`](/terraform/language/functions/base64encode).

## Examples

```
> textencodebase64("Hello World", "UTF-16LE")
SABlAGwAbABvACAAVwBvAHIAbABkAA==
```

## Related Functions

* [`textdecodebase64`](/terraform/language/functions/textdecodebase64) performs the opposite operation,
  decoding Base64 data and interpreting it as a particular character encoding.
* [`base64encode`](/terraform/language/functions/base64encode) applies Base64 encoding of the UTF-8
  encoding of a string.
* [`filebase64`](/terraform/language/functions/filebase64) reads a file from the local filesystem
  and returns its raw bytes with Base64 encoding, without creating an
  intermediate Unicode string.

TIMEADD                                                    *terraform-function-timeadd*

https://developer.hashicorp.com/terraform/language/functions/timeadd

---
page_title: timeadd function reference - Functions - Configuration Language
description: |-
  The timeadd function adds a duration to a timestamp, returning a new
  timestamp.
---

# `timeadd` function reference

This topic provices reference information about the `timeadd` function. 
`timeadd` adds a duration to a timestamp, returning a new timestamp.

## Introduction

The Terraform language represents timestamps as strings using [RFC
3339][rfc3339]'s Date and Time format.
`timeadd` requires that the `timestamp` argument is a string conforming to the Date and Time syntax.

## Syntax

Use the `timeadd` function with the following syntax:


```hcl
timeadd(timestamp, duration)
```

- `timestamp` is a string representation of a date in RFC 3339 format. Refer to the
  external RFC 3339's [Internet Date/Time Format section][date-time-format] for how to construct a timestamp string.
- `duration` is a string representation of a time difference. This string consists of
sequences of number and unit pairs, such as `"1.5h"` or `"1h30m"`. You may use
the following units:

  - `ns`: nanosecond
  - `us` or `µs`: microsecond
  - `ms`: millisecond
  - `s`: second
  - `m`: minute
  - `h`: hour

  To indicate a negative duration, make the first number negative, such as `"-2h5m"`.

The `timeadd` result is a string, also in RFC 3339 format, representing the result
of adding the given duration to the given timestamp.

## Example use case

This example adds ten minutes.

```hcl
> timeadd("2024-08-16T12:45:05Z", "10m")
"2024-08-16T12:55:05Z"
```

This example subtracts ten minutes by using a negative duration.

```hcl
> timeadd("2024-08-16T12:45:05Z", "-10m")
"2024-08-16T12:35:05Z"
```

# Related Functions

* [`timecmp`](/terraform/language/functions/timecmp) determines an ordering for two timestamps.

[rfc3339]: https://tools.ietf.org/html/rfc3339
[date-time-format]: https://datatracker.ietf.org/doc/html/rfc3339#section-5.6

TIMECMP                                                    *terraform-function-timecmp*

https://developer.hashicorp.com/terraform/language/functions/timecmp

---
page_title: timecmp - Functions - Configuration Language
description: |-
  The timecmp function adds a duration to a timestamp, returning a new
  timestamp.
---

# `timecmp` Function

`timecmp` compares two timestamps and returns a number that represents the
ordering of the instants those timestamps represent.

```hcl
timecmp(timestamp_a, timestamp_b)
```

| Condition                                          | Return Value |
|----------------------------------------------------|--------------|
| `timestamp_a` is before `timestamp_b`              | `-1`         |
| `timestamp_a` is the same instant as `timestamp_b` | `0`          |
| `timestamp_a` is after `timestamp_b`               | `1`          |

When comparing the timestamps, `timecmp` takes into account the UTC offsets
given in each timestamp. For example, `06:00:00+0200` and `04:00:00Z` are
the same instant after taking into account the `+0200` offset on the first
timestamp.

In the Terraform language, timestamps are conventionally represented as
strings using [RFC 3339](https://tools.ietf.org/html/rfc3339)
"Date and Time format" syntax. `timecmp` requires the its two arguments to
both be strings conforming to this syntax.

## Examples

```
> timecmp("2017-11-22T00:00:00Z", "2017-11-22T00:00:00Z")
0
> timecmp("2017-11-22T00:00:00Z", "2017-11-22T01:00:00Z")
-1
> timecmp("2017-11-22T01:00:00Z", "2017-11-22T00:00:00Z")
1
> timecmp("2017-11-22T01:00:00Z", "2017-11-22T00:00:00-01:00")
0
```

`timecmp` can be particularly useful in defining
[custom condition checks](/terraform/language/expressions/custom-conditions) that
involve a specified timestamp being within a particular range. For example,
the following resource postcondition would raise an error if a TLS certificate
(or other expiring object) expires sooner than 30 days from the time of
the "apply" step:

```hcl
  lifecycle {
    postcondition {
      condition     = timecmp(timestamp(), timeadd(self.expiration_timestamp, "-720h")) < 0
      error_message = "Certificate will expire in less than 30 days."
    }
  }
```

## Related Functions

* [`timestamp`](/terraform/language/functions/timestamp) returns the current timestamp when it is evaluated
  during the apply step.
* [`timeadd`](/terraform/language/functions/timeadd) can perform arithmetic on timestamps by adding or removing a specified duration.

TIMESTAMP                                                  *terraform-function-timestamp*

https://developer.hashicorp.com/terraform/language/functions/timestamp

---
page_title: timestamp - Functions - Configuration Language
description: |-
  The timestamp function returns a string representation of the current date
  and time.
---

# `timestamp` Function

`timestamp` returns a UTC timestamp string in [RFC 3339](https://tools.ietf.org/html/rfc3339) format.

In the Terraform language, timestamps are conventionally represented as
strings using [RFC 3339](https://tools.ietf.org/html/rfc3339)
"Date and Time format" syntax, and so `timestamp` returns a string
in this format.

The result of this function will change every second, so using this function
directly with resource attributes will cause a diff to be detected on every
Terraform run. We do not recommend using this function in resource attributes,
but in rare cases it can be used in conjunction with
[the `ignore_changes` lifecycle meta-argument](/terraform/language/meta-arguments/lifecycle#ignore_changes)
to take the timestamp only on initial creation of the resource. For more stable
time handling, see the [Time Provider](https://registry.terraform.io/providers/hashicorp/time).

Due to the constantly changing return value, the result of this function cannot
be predicted during Terraform's planning phase, and so the timestamp will be
taken only once the plan is being applied.

## Examples

```
> timestamp()
2018-05-13T07:44:12Z
```

## Related Functions

* [`formatdate`](/terraform/language/functions/formatdate) can convert the resulting timestamp to
  other date and time formats.
* [`plantimestamp`](/terraform/language/functions/plantimestamp) will return a consistent timestamp
  representing the date and time during the plan.

TITLE                                                      *terraform-function-title*

https://developer.hashicorp.com/terraform/language/functions/title

---
page_title: title - Functions - Configuration Language
description: |-
  The title function converts the first letter of each word in a given string
  to uppercase.
---

# `title` Function

`title` converts the first letter of each word in the given string to uppercase. The `title` function does not change any other letters in the string.

## Examples

```
> title("hello world")
Hello World
```
```
> title ("HELLO WORLD")
"HELLO WORLD"
```

This function uses Unicode's definition of letters and of upper- and lowercase.

## Related Functions

* [`upper`](/terraform/language/functions/upper) converts _all_ letters in a string to uppercase.
* [`lower`](/terraform/language/functions/lower) converts all letters in a string to lowercase.

TOBOOL                                                     *terraform-function-tobool*

https://developer.hashicorp.com/terraform/language/functions/tobool

---
page_title: tobool - Functions - Configuration Language
description: The tobool function converts a value to boolean.
---

# `tobool` Function

`tobool` converts its argument to a boolean value.

Explicit type conversions are rarely necessary in Terraform because it will
convert types automatically where required. Use the explicit type conversion
functions only to normalize types returned in module outputs.

Only boolean values, `null`, and the exact strings `"true"` and `"false"` can be
converted to boolean. All other values will produce an error.

## Examples

```
> tobool(true)
true
> tobool("true")
true
> tobool(null)
null
> tobool("no")
Error: Invalid function argument

Invalid value for "v" parameter: cannot convert "no" to bool: only the strings
"true" or "false" are allowed.

> tobool(1)
Error: Invalid function argument

Invalid value for "v" parameter: cannot convert number to bool.
```

TOLIST                                                     *terraform-function-tolist*

https://developer.hashicorp.com/terraform/language/functions/tolist

---
page_title: tolist - Functions - Configuration Language
description: The tolist function converts a value to a list.
---

# `tolist` Function

`tolist` converts its argument to a list value.

Explicit type conversions are rarely necessary in Terraform because it will
convert types automatically where required. Use the explicit type conversion
functions only to normalize types returned in module outputs.

Pass a _set_ value to `tolist` to convert it to a list. Since set elements are
not ordered, the resulting list will have an undefined order that will be
consistent within a particular run of Terraform.

## Examples

```
> tolist(["a", "b", "c"])
[
  "a",
  "b",
  "c",
]
```

Since Terraform's concept of a list requires all of the elements to be of the
same type, mixed-typed elements will be converted to the most general type:

```
> tolist(["a", "b", 3])
[
  "a",
  "b",
  "3",
]
```

TOMAP                                                      *terraform-function-tomap*

https://developer.hashicorp.com/terraform/language/functions/tomap

---
page_title: tomap - Functions - Configuration Language
description: The tomap function converts a value to a map.
---

# `tomap` Function

`tomap` converts its argument to a map value.

Explicit type conversions are rarely necessary in Terraform because it will
convert types automatically where required. Use the explicit type conversion
functions only to normalize types returned in module outputs.

## Examples

```
> tomap({"a" = 1, "b" = 2})
{
  "a" = 1
  "b" = 2
}
```

Since Terraform's concept of a map requires all of the elements to be of the
same type, mixed-typed elements will be converted to the most general type:

```
> tomap({"a" = "foo", "b" = true})
{
  "a" = "foo"
  "b" = "true"
}
```

TONUMBER                                                   *terraform-function-tonumber*

https://developer.hashicorp.com/terraform/language/functions/tonumber

---
page_title: tonumber - Functions - Configuration Language
description: The tonumber function converts a value to a number.
---

# `tonumber` Function

`tonumber` converts its argument to a number value.

Explicit type conversions are rarely necessary in Terraform because it will
convert types automatically where required. Use the explicit type conversion
functions only to normalize types returned in module outputs.

Only numbers, `null`, and strings containing decimal representations of numbers can be
converted to number. All other values will produce an error.

## Examples

```
> tonumber(1)
1
> tonumber("1")
1
> tonumber(null)
null
> tonumber("no")
Error: Invalid function argument

Invalid value for "v" parameter: cannot convert "no" to number: string must be
a decimal representation of a number.
```

TOSET                                                      *terraform-function-toset*

https://developer.hashicorp.com/terraform/language/functions/toset

---
page_title: toset - Functions - Configuration Language
description: The toset function converts a value to a set.
---

# `toset` Function

`toset` converts its argument to a set value.

Explicit type conversions are rarely necessary in Terraform because it will
convert types automatically where required. Use the explicit type conversion
functions only to normalize types returned in module outputs.

Pass a _list_ value to `toset` to convert it to a set, which will remove any
duplicate elements and discard the ordering of the elements.

## Examples

```
> toset(["a", "b", "c"])
[
  "a",
  "b",
  "c",
]
```

Since Terraform's concept of a set requires all of the elements to be of the
same type, mixed-typed elements will be converted to the most general type:

```
> toset(["a", "b", 3])
[
  "3",
  "a",
  "b",
]
```

Set collections are unordered and cannot contain duplicate values, so the
ordering of the argument elements is lost and any duplicate values are
coalesced:

```
> toset(["c", "b", "b"])
[
  "b",
  "c",
]
```

TOSTRING                                                   *terraform-function-tostring*

https://developer.hashicorp.com/terraform/language/functions/tostring

---
page_title: tostring - Functions - Configuration Language
description: The tostring function converts a value to a string.
---

# `tostring` Function

`tostring` converts its argument to a string value.

Explicit type conversions are rarely necessary in Terraform because it will
convert types automatically where required. Use the explicit type conversion
functions only to normalize types returned in module outputs.

Only the primitive types (string, number, and bool) and `null` can be converted to string.
`tostring(null)` produces a `null` value of type `string`. All other values produce an error. 

## Examples

```
> tostring("hello")
"hello"
> tostring(1)
"1"
> tostring(true)
"true"
> tostring(null)
tostring(null)
> tostring([])
Error: Invalid function argument

Invalid value for "v" parameter: cannot convert tuple to string.
```

TRANSPOSE                                                  *terraform-function-transpose*

https://developer.hashicorp.com/terraform/language/functions/transpose

---
page_title: transpose - Functions - Configuration Language
description: |-
  The transpose function takes a map of lists of strings and swaps the keys
  and values.
---

# `transpose` Function

`transpose` takes a map of lists of strings and swaps the keys and values
to produce a new map of lists of strings.

## Examples

```
> transpose({"a" = ["1", "2"], "b" = ["2", "3"]})
{
  "1" = [
    "a",
  ],
  "2" = [
    "a",
    "b",
  ],
  "3" = [
    "b",
  ],
}
```

TRIM                                                       *terraform-function-trim*

https://developer.hashicorp.com/terraform/language/functions/trim

---
page_title: trim - Functions - Configuration Language
description: >-
  The trim function removes the specified set of characters from the start and
  end of

  a given string.
---

# `trim` Function

`trim` removes the specified set of characters from the start and end of the given
string.

```hcl
trim(string, str_character_set)
```

Every occurrence of a character in the second argument is removed from the start
and end of the string specified in the first argument.

## Examples

```
> trim("?!hello?!", "!?")
"hello"

> trim("foobar", "far")
"oob"

> trim("   hello! world.!  ", "! ")
"hello! world."
```

## Related Functions

* [`trimprefix`](/terraform/language/functions/trimprefix) removes a word from the start of a string.
* [`trimsuffix`](/terraform/language/functions/trimsuffix) removes a word from the end of a string.
* [`trimspace`](/terraform/language/functions/trimspace) removes all types of whitespace from
  both the start and the end of a string.

TRIMPREFIX                                                 *terraform-function-trimprefix*

https://developer.hashicorp.com/terraform/language/functions/trimprefix

---
page_title: trimprefix - Functions - Configuration Language
description: |-
  The trimprefix function removes the specified prefix from the start of a
  given string.
---

# `trimprefix` Function

`trimprefix` removes the specified prefix from the start of the given string, but only once. If the string does not begin with the prefix, the original string is returned unchanged.

## Examples

```
> trimprefix("helloworld", "hello")
world
```

```
> trimprefix("helloworld", "cat")
helloworld
```

```
> trimprefix("--hello", "-")
-hello
```

## Related Functions

* [`trim`](/terraform/language/functions/trim) removes characters at the start and end of a string.
* [`trimsuffix`](/terraform/language/functions/trimsuffix) removes a word from the end of a string.
* [`trimspace`](/terraform/language/functions/trimspace) removes all types of whitespace from
  both the start and the end of a string.

TRIMSPACE                                                  *terraform-function-trimspace*

https://developer.hashicorp.com/terraform/language/functions/trimspace

---
page_title: trimspace - Functions - Configuration Language
description: |-
  The trimspace function removes space characters from the start and end of
  a given string.
---

# `trimspace` Function

`trimspace` removes any space characters from the start and end of the given
string.

This function follows the Unicode definition of "space", which includes
regular spaces, tabs, newline characters, and various other space-like
characters.

## Examples

```
> trimspace("  hello\n\n")
hello
```

## Related Functions

* [`chomp`](/terraform/language/functions/chomp) removes just line ending characters from the _end_ of
  a string.

TRIMSUFFIX                                                 *terraform-function-trimsuffix*

https://developer.hashicorp.com/terraform/language/functions/trimsuffix

---
page_title: trimsuffix - Functions - Configuration Language
description: |-
  The trimsuffix function removes the specified suffix from the end of a
  given string.
---

# `trimsuffix` Function

`trimsuffix` removes the specified suffix from the end of the given string, but only once, even if the suffix appears multiple times. If the suffix does not appear at the very end of the string, the original string is returned unchanged.

## Examples

```
> trimsuffix("helloworld", "world")
hello
```

```
> trimsuffix("helloworld", "cat")
helloworld
```

```
> trimsuffix("hello--", "-")
hello-
```

## Related Functions

* [`trim`](/terraform/language/functions/trim) removes characters at the start and end of a string.
* [`trimprefix`](/terraform/language/functions/trimprefix) removes a word from the start of a string.
* [`trimspace`](/terraform/language/functions/trimspace) removes all types of whitespace from
  both the start and the end of a string.

TRY                                                        *terraform-function-try*

https://developer.hashicorp.com/terraform/language/functions/try

---
page_title: try - Functions - Configuration Language
description: |-
  The try function tries to evaluate a sequence of expressions given as
  arguments and returns the result of the first one that does not produce
  any errors.
---

# `try` Function

`try` evaluates all of its argument expressions in turn and returns the result
of the first one that does not produce any errors.

This is a special function that is able to catch errors produced when evaluating
its arguments, which is particularly useful when working with complex data
structures whose shape is not well-known at implementation time.

For example, if some data is retrieved from an external system in JSON or YAML
format and then decoded, the result may have attributes that are not guaranteed
to be set. We can use `try` to produce a normalized data structure which has
a predictable type that can therefore be used more conveniently elsewhere in
the configuration:

```hcl
locals {
  raw_value = yamldecode(file("${path.module}/example.yaml"))
  normalized_value = {
    name   = tostring(try(local.raw_value.name, null))
    groups = try(local.raw_value.groups, [])
  }
}
```

With the above local value expressions, configuration elsewhere in the module
can refer to `local.normalized_value` attributes without the need to repeatedly
check for and handle absent attributes that would otherwise produce errors.

We can also use `try` to deal with situations where a value might be provided
in two different forms, allowing us to normalize to the most general form:

```hcl
variable "example" {
  type = any
}

locals {
  example = try(
    [tostring(var.example)],
    tolist(var.example),
  )
}
```

The above permits `var.example` to be either a list or a single string. If it's
a single string then it'll be normalized to a single-element list containing
that string, again allowing expressions elsewhere in the configuration to just
assume that `local.example` is always a list.

This second example contains two expressions that can both potentially fail.
For example, if `var.example` were set to `{}` then it could be converted to
neither a string nor a list. If `try` exhausts all of the given expressions
without any succeeding, it will return an error describing all of the problems
it encountered.

We strongly suggest using `try` only in special local values whose expressions
perform normalization, so that the error handling is confined to a single
location in the module and the rest of the module can just use straightforward
references to the normalized structure and thus be more readable for future
maintainers.

The `try` function can only catch and handle _dynamic_ errors resulting from
access to data that isn't known until runtime. It will not catch errors
relating to expressions that can be proven to be invalid for any input, such
as a malformed resource reference.

~> **Warning:** The `try` function is intended only for concise testing of the
presence of and types of object attributes. Although it can technically accept
any sort of expression, we recommend using it only with simple attribute
references and type conversion functions as shown in the examples above.
Overuse of `try` to suppress errors will lead to a configuration that is hard
to understand and maintain.

## Examples

```
> local.foo
{
  "bar" = "baz"
}
> try(local.foo.bar, "fallback")
baz
> try(local.foo.boop, "fallback")
fallback
```

The `try` function will _not_ catch errors relating to constructs that are
provably invalid even before dynamic expression evaluation, such as a malformed
reference or a reference to a top-level object that has not been declared:

```
> try(local.nonexist, "fallback")

Error: Reference to undeclared local value

A local value with the name "nonexist" has not been declared.
```

## Related Functions

* [`can`](/terraform/language/functions/can), which tries evaluating an expression and returns a
  boolean value indicating whether it succeeded.

TYPE                                                       *terraform-function-type*

https://developer.hashicorp.com/terraform/language/functions/type

---
page_title: type - Functions - Configuration Language
description: 'The type function returns the type of a given value. '
---

# `type` Function

-> **Note:** This function is available only in Terraform 1.0 and later.

`type` returns the type of a given value.

Sometimes a Terraform configuration can result in confusing errors regarding
inconsistent types. This function displays terraform's evaluation of a given
value's type, which is useful in understanding this error message.

This is a special function which is only available in the `terraform console`
command. It can only be used to examine the type of a given value, and should
not be used in more complex expressions.

## Examples

Here we have a conditional `output` which prints either the value of `var.list` or a local named `default_list`:

```hcl
variable "list" {
  default = []
}

locals {
  default_list = [
    {
      foo = "bar"
      map = { bleep = "bloop" }
    },
    {
      beep = "boop"
    },
  ]
}

output "list" {
  value = var.list != [] ? var.list : local.default_list
}
```

Applying this configuration results in the following error:

```
Error: Inconsistent conditional result types

  on main.tf line 18, in output "list":
  18:   value = var.list != [] ? var.list : local.default_list
    |----------------
    | local.default_list is tuple with 2 elements
    | var.list is empty tuple

The true and false result expressions must have consistent types. The given
expressions are tuple and tuple, respectively.
```

While this error message does include some type information, it can be helpful
to inspect the exact type that Terraform has determined for each given input.
Examining both `var.list` and `local.default_list` using the `type` function
provides more context for the error message:

```
> type(var.list)
tuple
> type(local.default_list)
tuple([
    object({
        foo: string,
        map: object({
            bleep: string,
        }),
    }),
    object({
        beep: string,
    }),
])
```

UPPER                                                      *terraform-function-upper*

https://developer.hashicorp.com/terraform/language/functions/upper

---
page_title: upper - Functions - Configuration Language
description: >-
  The upper function converts all cased letters in the given string to
  uppercase.
---

# `upper` Function

`upper` converts all cased letters in the given string to uppercase.

## Examples

```
> upper("hello")
HELLO
> upper("алло!")
АЛЛО!
```

This function uses Unicode's definition of letters and of upper- and lowercase.

## Related Functions

* [`lower`](/terraform/language/functions/lower) converts letters in a string to _lowercase_.
* [`title`](/terraform/language/functions/title) converts the first letter of each word in a string to uppercase.

URLENCODE                                                  *terraform-function-urlencode*

https://developer.hashicorp.com/terraform/language/functions/urlencode

---
page_title: urlencode - Functions - Configuration Language
description: The urlencode function applies URL encoding to a given string.
---

# `urlencode` Function

`urlencode` applies URL encoding to a given string.

This function identifies characters in the given string that would have a
special meaning when included as a query string argument in a URL and
escapes them using
[RFC 3986 "percent encoding"](https://tools.ietf.org/html/rfc3986#section-2.1).

The exact set of characters escaped may change over time, but the result
is guaranteed to be interpolatable into a query string argument without
inadvertently introducing additional delimiters.

If the given string contains non-ASCII characters, these are first encoded as
UTF-8 and then percent encoding is applied separately to each UTF-8 byte.

## Examples

```
> urlencode("Hello World!")
Hello+World%21
> urlencode("☃")
%E2%98%83
> "http://example.com/search?q=${urlencode("terraform urlencode")}"
http://example.com/search?q=terraform+urlencode
```

UUID                                                       *terraform-function-uuid*

https://developer.hashicorp.com/terraform/language/functions/uuid

---
page_title: uuid - Functions - Configuration Language
description: The uuid function generates a unique id.
---

# `uuid` Function

`uuid` generates UUID-format strings using random bytes.

The function generates a well-understood string representation of a 128-bit value, but the output is not RFC-compliant.

This function produces a new value each time it is called, and so using it
directly in resource arguments will result in spurious diffs. We do not
recommend using the `uuid` function in resource configurations, but it can
be used with care in conjunction with
[the `ignore_changes` lifecycle meta-argument](/terraform/language/meta-arguments/lifecycle#ignore_changes).

In most cases we recommend using [the `random` provider](https://registry.terraform.io/providers/hashicorp/random/latest/docs)
instead, since it allows the one-time generation of random values that are
then retained in the Terraform [state](/terraform/language/state) for use by
future operations. In particular,
[`random_id`](https://registry.terraform.io/providers/hashicorp/random/latest/docs/resources/id) can generate results with
equivalent randomness to the `uuid` function.

## Examples

```
> uuid()
b5ee72a3-54dd-c4b8-551c-4bdc0204cedb
```

## Related Functions

* [`uuidv5`](/terraform/language/functions/uuidv5), which generates name-based UUIDs.

UUIDV5                                                     *terraform-function-uuidv5*

https://developer.hashicorp.com/terraform/language/functions/uuidv5

---
page_title: uuidv5 - Functions - Configuration Language
description: >-
  The uuidv5 function generates a uuid v5 string representation of the value in
  the specified namespace.
---

# `uuidv5` Function

`uuidv5` generates a _name-based_ UUID, as described in
[RFC 4122 section 4.3](https://tools.ietf.org/html/rfc4122#section-4.3),
also known as a "version 5" UUID.

```
uuidv5(namespace, name)
```

Unlike the pseudo-random UUIDs generated by
[`uuid`](/terraform/language/functions/uuid), name-based UUIDs derive from namespace and an name,
producing the same UUID value every time if the namespace and name are
unchanged.

Name-based UUID namespaces are themselves UUIDs, but for readability this
function accepts some keywords as aliases for the namespaces that were
assigned by RFC 4122:

| Keyword  | Namespace ID                           | Name format                                                                  |
| -------- | -------------------------------------- | ---------------------------------------------------------------------------- |
| `"dns"`  | `6ba7b810-9dad-11d1-80b4-00c04fd430c8` | A fully-qualified DNS domain name.                                           |
| `"url"`  | `6ba7b811-9dad-11d1-80b4-00c04fd430c8` | Any valid URL as defined in [RFC 3986](https://tools.ietf.org/html/rfc3986). |
| `"oid"`  | `6ba7b812-9dad-11d1-80b4-00c04fd430c8` | An [ISO/IEC object identifier](https://oidref.com/)                          |
| `"x500"` | `6ba7b814-9dad-11d1-80b4-00c04fd430c8` | [X.500 Distinguished Name](https://tools.ietf.org/html/rfc1779)              |

To use any other namespace not included in the above table, pass its assigned
namespace ID directly in the first argument in the usual UUID string format.

## Examples

Use the namespace keywords where possible, to make the intent more obvious to
a future reader:

```
> uuidv5("dns", "www.terraform.io")
a5008fae-b28c-5ba5-96cd-82b4c53552d6

> uuidv5("url", "https://www.terraform.io/")
9db6f67c-dd95-5ea0-aa5b-e70e5c5f7cf5

> uuidv5("oid", "1.3.6.1.4")
af9d40a5-7a36-5c07-b23a-851cd99fbfa5

> uuidv5("x500", "CN=Example,C=GB")
84e09961-4aa4-57f8-95b7-03edb1073253
```

The namespace keywords treated as equivalent to their corresponding namespace
UUIDs, and in some special cases it may be more appropriate to use the
UUID form:

```
> uuidv5("6ba7b810-9dad-11d1-80b4-00c04fd430c8", "www.terraform.io")
a5008fae-b28c-5ba5-96cd-82b4c53552d6
```

If you wish to use a namespace defined outside of RFC 4122, using the namespace
UUID is required because no corresponding keyword is available:

```
> uuidv5("743ac3c0-3bf7-4a5b-9e6c-59360447c757", "LIBS:diskfont.library")
ede1a974-df7e-5f17-84b9-76208818b2c8
```

When using raw UUID namespaces, consider including a comment alongside the
expression that indicates which namespace this represents in a
human-significant manner, such as by reference to the standard that
defined it.

## Related Functions

* [`uuid`](/terraform/language/functions/uuid), which generates pseudorandom UUIDs.

VALUES                                                     *terraform-function-values*

https://developer.hashicorp.com/terraform/language/functions/values

---
page_title: values - Functions - Configuration Language
description: The values function returns a list of the element values in a given map.
---

# `values` Function

`values` takes a map and returns a list containing the values of the elements
in that map.

The values are returned in lexicographical order by their corresponding _keys_,
so the values will be returned in the same order as their keys would be
returned from [`keys`](/terraform/language/functions/keys).

## Examples

```
> values({a=3, c=2, d=1})
[
  3,
  2,
  1,
]
```

## Related Functions

* [`keys`](/terraform/language/functions/keys) returns a list of the _keys_ from a map.

YAMLDECODE                                                 *terraform-function-yamldecode*

https://developer.hashicorp.com/terraform/language/functions/yamldecode

---
page_title: yamldecode - Functions - Configuration Language
description: |-
  The yamldecode function decodes a YAML string into a representation of its
  value.
---

# `yamldecode` Function

`yamldecode` parses a string as a subset of YAML, and produces a representation
of its value.

This function supports a subset of [YAML 1.2](https://yaml.org/spec/1.2/spec.html),
as described below.

This function maps YAML values to
[Terraform language values](/terraform/language/expressions/types)
in the following way:

| YAML type     | Terraform type                                                     |
| ------------- | ------------------------------------------------------------------ |
| `!!str`       | `string`                                                           |
| `!!float`     | `number`                                                           |
| `!!int`       | `number`                                                           |
| `!!bool`      | `bool`                                                             |
| `!!map`       | `object(...)` with attribute types determined per this table       |
| `!!seq`       | `tuple(...)` with element types determined per this table          |
| `!!null`      | The Terraform language `null` value                                |
| `!!timestamp` | `string` in [RFC 3339](https://tools.ietf.org/html/rfc3339) format |
| `!!binary`    | `string` containing base64-encoded representation                  |

The Terraform language automatic type conversion rules mean that you don't
usually need to worry about exactly what type is produced for a given value,
and can just use the result in an intuitive way.

Note though that the mapping above is ambiguous -- several different source
types map to the same target type -- and so round-tripping through `yamldecode`
and then `yamlencode` cannot produce an identical result.

YAML is a complex language and it supports a number of possibilities that the
Terraform language's type system cannot represent. Therefore this YAML decoder
supports only a subset of YAML 1.2, with restrictions including the following:

- Although aliases to earlier anchors are supported, cyclic data structures
  (where a reference to a collection appears inside that collection) are not.
  If `yamldecode` detects such a structure then it will return an error.

- Only the type tags shown in the above table (or equivalent alternative
  representations of those same tags) are supported. Any other tags will
  result in an error.

- Only one YAML document is permitted. If multiple documents are present in
  the given string then this function will return an error.

## Examples

```
> yamldecode("hello: world")
{
  "hello" = "world"
}

> yamldecode("true")
true

> yamldecode("{a: &foo [1, 2, 3], b: *foo}")
{
  "a" = [
    1,
    2,
    3,
  ]
  "b" = [
    1,
    2,
    3,
  ]
}

> yamldecode("{a: &foo [1, *foo, 3]}")

Error: Error in function call

Call to function "yamldecode" failed: cannot refer to anchor "foo" from inside
its own definition.

> yamldecode("{a: !not-supported foo}")

Error: Error in function call

Call to function "yamldecode" failed: unsupported tag "!not-supported".
```

## Related Functions

- [`jsondecode`](/terraform/language/functions/jsondecode) is a similar operation using JSON instead
  of YAML.
- [`yamlencode`](/terraform/language/functions/yamlencode) performs the opposite operation, _encoding_
  a value as YAML.

YAMLENCODE                                                 *terraform-function-yamlencode*

https://developer.hashicorp.com/terraform/language/functions/yamlencode

---
page_title: yamlencode - Functions - Configuration Language
description: The yamlencode function encodes a given value as a YAML string.
---

# `yamlencode` Function

`yamlencode` encodes a given value to a string using
[YAML 1.2](https://yaml.org/spec/1.2/spec.html) block syntax.

This function maps
[Terraform language values](/terraform/language/expressions/types)
to YAML tags in the following way:

| Terraform type | YAML type            |
| -------------- | -------------------- |
| `string`       | `!!str`              |
| `number`       | `!!float` or `!!int` |
| `bool`         | `!!bool`             |
| `list(...)`    | `!!seq`              |
| `set(...)`     | `!!seq`              |
| `tuple(...)`   | `!!seq`              |
| `map(...)`     | `!!map`              |
| `object(...)`  | `!!map`              |
| Null value     | `!!null`             |

`yamlencode` uses the implied syntaxes for all of the above types, so it does
not generate explicit YAML tags.

Because the YAML format cannot fully represent all of the Terraform language
types, passing the `yamlencode` result to `yamldecode` will not produce an
identical value, but the Terraform language automatic type conversion rules
mean that this is rarely a problem in practice.

YAML is a superset of JSON, and so where possible we recommend generating
JSON using [`jsonencode`](/terraform/language/functions/jsonencode) instead, even if
a remote system supports YAML. JSON syntax is equivalent to flow-style YAML
and Terraform can present detailed structural change information for JSON
values in plans, whereas Terraform will treat block-style YAML just as a normal
multi-line string. However, generating YAML may improve readability if the
resulting value will be directly read or modified in the remote system by
humans.

## Examples

```
> yamlencode({"a":"b", "c":"d"})
"a": "b"
"c": "d"

> yamlencode({"foo":[1, 2, 3], "bar": "baz"})
"bar": "baz"
"foo":
- 1
- 2
- 3

> yamlencode({"foo":[1, {"a":"b","c":"d"}, 3], "bar": "baz"})
"bar": "baz"
"foo":
- 1
- "a": "b"
  "c": "d"
- 3
```

`yamlencode` always uses YAML's "block style" for mappings and sequences, unless
the mapping or sequence is empty. To generate flow-style YAML, use
[`jsonencode`](/terraform/language/functions/jsonencode) instead: YAML flow-style is a superset
of JSON syntax.

## Related Functions

- [`jsonencode`](/terraform/language/functions/jsonencode) is a similar operation using JSON instead
  of YAML.
- [`yamldecode`](/terraform/language/functions/yamldecode) performs the opposite operation, _decoding_
  a YAML string to obtain its represented value.

ZIPMAP                                                     *terraform-function-zipmap*

https://developer.hashicorp.com/terraform/language/functions/zipmap

---
page_title: zipmap - Functions - Configuration Language
description: |-
  The zipmap function constructs a map from a list of keys and a corresponding
  list of values.
---

# `zipmap` Function

`zipmap` constructs a map from a list of keys and a corresponding list of
values.

```hcl
zipmap(keyslist, valueslist)
```

Both `keyslist` and `valueslist` must be of the same length. `keyslist` must
be a list of strings, while `valueslist` can be a list of any type.

Each pair of elements with the same index from the two lists will be used
as the key and value of an element in the resulting map. If the same value
appears multiple times in `keyslist` then the value with the highest index
is used in the resulting map.

## Examples

```
> zipmap(["a", "b"], [1, 2])
{
  "a" = 1
  "b" = 2
}
```
vim:tw=78:ts=8:noet:ft=help:norl:
